# Copyright 2025 Roger Cibrian
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Requirements script generation for Intune Win32 apps.

This module generates PowerShell requirements scripts for Intune Win32 app
deployments. Requirements scripts determine if the Update entry should be
applicable to a device based on whether an older version is installed.

Requirements Logic:
    - Checks HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall (always)
    - Checks HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall (always)
    - Checks HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall
        (only on 64-bit OS with 64-bit PowerShell process)
    - Checks HKCU:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall
        (only on 64-bit OS with 64-bit PowerShell process)
    - Matches by DisplayName (using AppName from recipe or MSI ProductName)
    - If installed version < target version: outputs "Required" and exits 0
    - Otherwise: outputs nothing and exits 0

Installer Type Filtering:
    Scripts filter registry entries based on installer type to prevent false
    matches when both MSI and EXE versions of software exist:

    - MSI installers (strict): Only matches registry entries with
        WindowsInstaller=1. Prevents false matches with EXE versions.
    - Non-MSI installers (permissive): Matches ANY registry entry. Handles
        EXE installers that run embedded MSIs internally.

Logging:
    - Primary (System): C:\\ProgramData\\Microsoft\\IntuneManagementExtension\\Logs\\NAPTRequirements.log
    - Primary (User): C:\\ProgramData\\Microsoft\\IntuneManagementExtension\\Logs\\NAPTRequirementsUser.log
    - Fallback (System): C:\\ProgramData\\NAPT\\NAPTRequirements.log
    - Fallback (User): %LOCALAPPDATA%\\NAPT\\NAPTRequirementsUser.log
    - Log rotation: 2-file rotation (.log and .log.old), configurable max size
        (default: 3MB)
    - Format: CMTrace format for compatibility with Intune diagnostics

Example:
    Generate requirements script:
        ```python
        from pathlib import Path
        from notapkgtool.requirements import RequirementsConfig, generate_requirements_script

        config = RequirementsConfig(
            app_name="Google Chrome",
            version="131.0.6778.86",
        )
        script_path = generate_requirements_script(
            config=config,
            output_path=Path("builds/chrome/131.0.6778.86/Google-Chrome-131.0.6778.86-Requirements.ps1"),
        )
        ```

Note:
    Requirements scripts are saved as siblings to the packagefiles directory
    to prevent them from being included in the .intunewin package. They
    should be uploaded separately to Intune as a custom requirement rule
    with output type String, operator Equals, value "Required".

"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
import string
from typing import Literal

LogFormat = Literal["cmtrace"]
LogLevel = Literal["INFO", "WARNING", "ERROR", "DEBUG"]


@dataclass(frozen=True)
class RequirementsConfig:
    """Configuration for requirements script generation.

    Attributes:
        app_name: Application name to search for in registry DisplayName.
        version: Target version string (requirement met if installed < this).
        log_format: Log format (currently only "cmtrace" supported).
        log_level: Minimum log level (INFO, WARNING, ERROR, DEBUG).
        log_rotation_mb: Maximum log file size in MB before rotation.
        app_id: Application ID (used for fallback if app_name sanitization
            results in empty string).
        is_msi_installer: If True, only match MSI-based registry entries.
            If False, only match non-MSI entries. This prevents false matches
            when both MSI and EXE versions of software exist with the same
            DisplayName.

    """

    app_name: str
    version: str
    log_format: LogFormat = "cmtrace"
    log_level: LogLevel = "INFO"
    log_rotation_mb: int = 3
    app_id: str = ""
    is_msi_installer: bool = False


# PowerShell requirements script template
_REQUIREMENTS_SCRIPT_TEMPLATE = """# Requirements script for ${app_name} ${version}
# Generated by NAPT (Not a Package Tool)
# This script checks if an older version is installed (for Update entry applicability).
# Outputs "Required" if installed version < target version, nothing otherwise.
# Always exits with code 0 so Intune can evaluate STDOUT.

param(
    [string]$$AppName = "${app_name}",
    [string]$$TargetVersion = "${version}",
    [bool]$$IsMSIInstaller = ${is_msi_installer}
)

# CMTrace log format function
function Write-CMTraceLog {
    param(
        [string]$$Message,
        [string]$$Component = $$script:ComponentName,
        [string]$$Type = "INFO"  # "INFO", "WARNING", "ERROR", "DEBUG"
    )
    
    $$LogFile = $$script:LogFilePath
    
    if (-not $$LogFile) {
        return
    }
    
    # Convert string log level to CMTrace numeric type
    # 1=Info, 2=Warning, 3=Error, 4=Debug
    $$TypeNumber = switch ($$Type.ToUpper()) {
        "INFO" { 1 }
        "WARNING" { 2 }
        "ERROR" { 3 }
        "DEBUG" { 4 }
        default { 1 }  # Default to INFO if unknown
    }
    
    # Format time: HH:mm:ss.fff-offset (offset in minutes, e.g., -480 for -08:00)
    $$Now = [DateTimeOffset](Get-Date)
    $$TimeFormatted = $$Now.ToString("HH:mm:ss.fff")
    $$OffsetMinutes = [int]$$Now.Offset.TotalMinutes
    $$TimeWithOffset = "$$TimeFormatted$$OffsetMinutes"
    
    # Format date: M-d-yyyy (single digit month/day when appropriate)
    $$DateFormatted = $$Now.ToString("M-d-yyyy")
    
    # Get context (user identity name) and script file path
    $$ContextName = if ($$script:CurrentIdentity) { $$script:CurrentIdentity.Name } else { "UNKNOWN" }
    $$ScriptFile = if ($$MyInvocation.ScriptName) { $$MyInvocation.ScriptName } else { "requirements.ps1" }
    
    $$Line = "<![LOG[$$Message]LOG]!><time=""$$TimeWithOffset"" date=""$$DateFormatted"" component=""$$Component"" context=""$$ContextName"" type=""$$TypeNumber"" thread=""$$PID"" file=""$$ScriptFile"">"
    
    try {
        Add-Content -Path $$LogFile -Value $$Line -Encoding UTF8 -ErrorAction SilentlyContinue
    } catch {
        # Silently fail if we can't write to log
    }
}

# Determine log file location
function Initialize-LogFile {
    $$script:CurrentIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $$IsSystemContext = $$script:CurrentIdentity.Name -eq "NT AUTHORITY\\SYSTEM"
    
    if ($$IsSystemContext) {
        # System context - try Intune log folder first
        $$PrimaryLogDir = "C:\\ProgramData\\Microsoft\\IntuneManagementExtension\\Logs"
        $$PrimaryLogFile = Join-Path $$PrimaryLogDir "NAPTRequirements.log"
        $$FallbackLogDir = "C:\\ProgramData\\NAPT"
        $$FallbackLogFile = Join-Path $$FallbackLogDir "NAPTRequirements.log"
    } else {
        # User context
        $$PrimaryLogDir = "C:\\ProgramData\\Microsoft\\IntuneManagementExtension\\Logs"
        $$PrimaryLogFile = Join-Path $$PrimaryLogDir "NAPTRequirementsUser.log"
        $$FallbackLogDir = $$env:LOCALAPPDATA
        $$FallbackLogFile = Join-Path $$FallbackLogDir "NAPT\\NAPTRequirementsUser.log"
    }
    
    # Try primary location first
    try {
        # Ensure parent directory exists (fails with -ErrorAction Stop if no perms)
        $$PrimaryLogParent = Split-Path -Path $$PrimaryLogFile -Parent
        if (-not (Test-Path -Path $$PrimaryLogParent)) {
            New-Item -Path $$PrimaryLogParent -ItemType Directory -Force -ErrorAction Stop | Out-Null
        }
        
        # Handle log rotation if needed
        if (Test-Path -Path $$PrimaryLogFile) {
            $$LogSize = (Get-Item $$PrimaryLogFile).Length
            $$MaxSize = ${log_rotation_mb} * 1024 * 1024
            if ($$LogSize -ge $$MaxSize) {
                $$OldLogFile = "$$PrimaryLogFile.old"
                if (Test-Path $$OldLogFile) { Remove-Item $$OldLogFile -Force -ErrorAction Stop }
                Move-Item -Path $$PrimaryLogFile -Destination $$OldLogFile -Force -ErrorAction Stop
            }
        }
        
        # Verify write access (appends empty string - fails if no write permission)
        [System.IO.File]::AppendAllText($$PrimaryLogFile, "")
        $$script:LogFilePath = $$PrimaryLogFile
        return
    } catch {
        # Fall through to fallback (directory creation, rotation, or write failed)
    }
    
    # Fallback location
    try {
        $$FallbackLogParent = Split-Path -Path $$FallbackLogFile -Parent
        if (-not (Test-Path -Path $$FallbackLogParent)) {
            New-Item -Path $$FallbackLogParent -ItemType Directory -Force -ErrorAction Stop | Out-Null
        }
        
        if (Test-Path -Path $$FallbackLogFile) {
            $$LogSize = (Get-Item $$FallbackLogFile).Length
            $$MaxSize = ${log_rotation_mb} * 1024 * 1024
            if ($$LogSize -ge $$MaxSize) {
                $$OldLogFile = "$$FallbackLogFile.old"
                if (Test-Path $$OldLogFile) { Remove-Item $$OldLogFile -Force -ErrorAction Stop }
                Move-Item -Path $$FallbackLogFile -Destination $$OldLogFile -Force -ErrorAction Stop
            }
        }
        
        [System.IO.File]::AppendAllText($$FallbackLogFile, "")
        $$script:LogFilePath = $$FallbackLogFile
    } catch {
        # All log locations failed - log warning to stderr and continue
        Write-Warning "NAPT Requirements: Failed to initialize logging (primary and fallback locations unavailable). Script will continue but no log file will be created."
        $$script:LogFilePath = $$null
    }
}

# Check if registry entry is MSI-based installation
function Test-IsMSIInstallation {
    param(
        [Microsoft.Win32.RegistryKey]$$RegKey
    )
    
    # Check WindowsInstaller DWORD value - set automatically by Windows Installer
    # for all MSI installations. This is the authoritative indicator.
    $$WindowsInstaller = (Get-ItemProperty -Path $$RegKey.PSPath -Name "WindowsInstaller" -ErrorAction SilentlyContinue).WindowsInstaller
    return ($$WindowsInstaller -eq 1)
}

# Version comparison function - returns true if Installed < Target
function Compare-VersionLessThan {
    param(
        [string]$$InstalledVersion,
        [string]$$TargetVersion
    )
    
    # Parse version parts
    $$InstalledParts = $$InstalledVersion -split '[.\\-]' | ForEach-Object { [int]$$_ }
    $$TargetParts = $$TargetVersion -split '[.\\-]' | ForEach-Object { [int]$$_ }
    
    $$MaxLength = [Math]::Max($$InstalledParts.Count, $$TargetParts.Count)
    
    for ($$i = 0; $$i -lt $$MaxLength; $$i++) {
        $$InstalledPart = if ($$i -lt $$InstalledParts.Count) { $$InstalledParts[$$i] } else { 0 }
        $$TargetPart = if ($$i -lt $$TargetParts.Count) { $$TargetParts[$$i] } else { 0 }
        
        if ($$InstalledPart -lt $$TargetPart) {
            return $$true
        }
        if ($$InstalledPart -gt $$TargetPart) {
            return $$false
        }
    }
    
    return $$false  # Versions are equal, so not less than
}

# Main requirements logic
Initialize-LogFile

# Build component identifier from app name and version (sanitized for valid identifier)
$$SanitizedAppName = $$AppName -replace '[^a-zA-Z0-9]', '-' -replace '-+', '-' -replace '^-|-$$', ''
$$script:ComponentName = "$$SanitizedAppName-$$TargetVersion-Requirements"

Write-CMTraceLog -Message "[Initialization] Requirements script running as user: $$($$script:CurrentIdentity.Name)" -Type "INFO"
Write-CMTraceLog -Message "[Initialization] Starting requirements check for: $$AppName (Target: $$TargetVersion, Installer Type: $$(if ($$IsMSIInstaller) { 'MSI' } else { 'Non-MSI' }))" -Type "INFO"

# Detect if PowerShell is running as 64-bit process
$$Is64BitProcess = [Environment]::Is64BitProcess

# Detect OS architecture
$$OSArchitecture = (Get-CimInstance -ClassName Win32_OperatingSystem).OSArchitecture
$$Is64BitOS = $$OSArchitecture -eq "64-bit"

Write-CMTraceLog -Message "[Initialization] OS Architecture: $$OSArchitecture" -Type "INFO"
Write-CMTraceLog -Message "[Initialization] PowerShell Process: $$(if ($$Is64BitProcess) { '64-bit' } else { '32-bit' })" -Type "INFO"

# Build registry paths based on process and OS architecture
$$RegPaths = @(
    # Machine-level native path (always check)
    "HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
)

# User-level native path (always check)
$$RegPaths += "HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"

# Wow6432Node paths (only for 64-bit process on 64-bit OS)
if ($$Is64BitOS -and $$Is64BitProcess) {
    $$RegPaths += "HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
    $$RegPaths += "HKCU:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
}

Write-CMTraceLog -Message "[Initialization] Registry paths to check: $$($$RegPaths -join ', ')" -Type "INFO"

$$FoundOlderVersion = $$false
$$InstalledVersion = $$null
$$DisplayName = $$null

# Check all registry paths to find matching DisplayName and version
foreach ($$RegPath in $$RegPaths) {
    try {
        $$Keys = Get-ChildItem -Path $$RegPath -ErrorAction SilentlyContinue
        foreach ($$Key in $$Keys) {
            $$DisplayNameValue = (Get-ItemProperty -Path $$Key.PSPath -Name "DisplayName" -ErrorAction SilentlyContinue).DisplayName
            $$VersionValue = (Get-ItemProperty -Path $$Key.PSPath -Name "DisplayVersion" -ErrorAction SilentlyContinue).DisplayVersion
            
            if ($$DisplayNameValue -eq $$AppName) {
                # Convert PSPath to cleaner registry path format
                $$RegKeyPath = $$Key.PSPath -replace 'Microsoft\\.PowerShell\\.Core\\\\Registry::', '' -replace 'HKEY_LOCAL_MACHINE\\\\', 'HKLM:\\' -replace 'HKEY_CURRENT_USER\\\\', 'HKCU:\\'
                
                # Check if installer type matches (MSI vs non-MSI)
                # MSI installers: strict matching - only accept MSI registry entries
                # Non-MSI installers: permissive - accept any entry (EXEs may use embedded MSIs)
                $$IsMSIEntry = Test-IsMSIInstallation -RegKey $$Key
                if ($$IsMSIInstaller -and -not $$IsMSIEntry) {
                    # Building from MSI, but registry entry is not MSI - skip
                    Write-CMTraceLog -Message "[Requirements] Found matching DisplayName but installer type mismatch: '$$RegKeyPath' is non-MSI, expected MSI - skipping" -Type "INFO"
                    continue
                }
                # Note: Non-MSI installers accept ANY registry entry (MSI or non-MSI)
                # because EXE installers often wrap embedded MSIs that set WindowsInstaller=1
                
                $$DisplayName = $$DisplayNameValue
                $$InstalledVersion = $$VersionValue
                
                Write-CMTraceLog -Message "[Requirements] Found matching registry key: '$$RegKeyPath' (DisplayName: $$DisplayName, DisplayVersion: $$InstalledVersion, Installer Type: $$(if ($$IsMSIEntry) { 'MSI' } else { 'Non-MSI' }))" -Type "INFO"
                
                if ($$InstalledVersion) {
                    if (Compare-VersionLessThan -InstalledVersion $$InstalledVersion -TargetVersion $$TargetVersion) {
                        Write-CMTraceLog -Message "[Requirements] Version check PASSED: Installed version $$InstalledVersion is LESS THAN target version $$TargetVersion" -Type "INFO"
                        $$FoundOlderVersion = $$true
                        break
                    } else {
                        Write-CMTraceLog -Message "[Requirements] Version check FAILED: Installed version $$InstalledVersion is NOT less than target version $$TargetVersion" -Type "INFO"
                    }
                } else {
                    Write-CMTraceLog -Message "[Requirements] DisplayName '$$DisplayName' found but no DisplayVersion value is present" -Type "WARNING"
                }
            }
        }
        if ($$FoundOlderVersion) {
            break
        }
    } catch {
        Write-CMTraceLog -Message "[Requirements] Error checking registry path $$RegPath : $$($$_.Exception.Message)" -Type "ERROR"
    }
}

# Always exit 0 - Intune evaluates STDOUT
if ($$FoundOlderVersion) {
    Write-CMTraceLog -Message "[Result] Requirements MET: $$AppName (version $$InstalledVersion) is installed and is older than target version $$TargetVersion - outputting 'Required'" -Type "INFO"
    Write-Output "Required"
    exit 0
} else {
    if ($$DisplayName) {
        Write-CMTraceLog -Message "[Result] Requirements NOT MET: $$AppName is installed but version ($$InstalledVersion) is not older than target ($$TargetVersion)" -Type "WARNING"
    } else {
        Write-CMTraceLog -Message "[Result] Requirements NOT MET: $$AppName not found in registry" -Type "WARNING"
    }
    # Output nothing - requirement not met
    exit 0
}
"""


def generate_requirements_script(config: RequirementsConfig, output_path: Path) -> Path:
    """Generate PowerShell requirements script for Intune Win32 app.

    Creates a PowerShell script that checks Windows uninstall registry keys
    for software installation and determines if an older version is installed.
    The script outputs "Required" if installed version < target version,
    nothing otherwise. Always exits with code 0 so Intune can evaluate STDOUT.

    Args:
        config: Requirements configuration (app name, version, logging settings).
        output_path: Path where the requirements script will be saved.

    Returns:
        Path to the generated requirements script.

    Raises:
        OSError: If the script file cannot be written.

    Example:
        Generate script with default settings:
            ```python
            from pathlib import Path
            from notapkgtool.requirements import RequirementsConfig, generate_requirements_script

            config = RequirementsConfig(
                app_name="Google Chrome",
                version="131.0.6778.86",
            )
            script_path = generate_requirements_script(
                config,
                Path("requirements.ps1")
            )
            ```

    Note:
        The script is saved with UTF-8 BOM encoding for proper PowerShell
        execution on Windows systems.

    """
    from notapkgtool.logging import get_global_logger

    logger = get_global_logger()

    logger.verbose(
        "REQUIREMENTS", f"Generating requirements script: {output_path.name}"
    )

    # Generate script content from template
    # Use safe_substitute() so PowerShell variables ($$Variable) are preserved
    # as $Variable without raising KeyError for missing placeholders
    script_content = string.Template(_REQUIREMENTS_SCRIPT_TEMPLATE).safe_substitute(
        app_name=config.app_name,
        version=config.version,
        log_rotation_mb=config.log_rotation_mb,
        is_msi_installer="$True" if config.is_msi_installer else "$False",
    )

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Write script with UTF-8 BOM encoding (required for PowerShell)
    try:
        script_bytes = script_content.encode("utf-8-sig")
        output_path.write_bytes(script_bytes)
        logger.verbose("REQUIREMENTS", f"Requirements script written to: {output_path}")
    except OSError as err:
        raise OSError(
            f"Failed to write requirements script to {output_path}: {err}"
        ) from err

    return output_path
