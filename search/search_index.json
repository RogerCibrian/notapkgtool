{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NAPT - Not a Pkg Tool","text":"<p>Automated Windows application packaging and deployment to Microsoft Intune using PSAppDeployToolkit</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>NAPT is a Python-based CLI tool that automates the entire workflow for packaging Windows applications and deploying them to Microsoft Intune. It eliminates repetitive manual work through declarative YAML-based recipes and intelligent version discovery.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Declarative YAML recipes - Define app packaging once, run everywhere</li> <li>\u2705 Automatic version discovery - Extract versions from MSI, EXE, URLs, or APIs</li> <li>\u2705 Robust downloads - Retry logic, conditional requests (ETags), atomic writes</li> <li>\u2705 Intelligent caching - Version-first strategies can skip downloads entirely when unchanged</li> <li>\u2705 Dual-path optimization - Version-first (instant checks) and file-first (ETag) strategies</li> <li>\u2705 Cross-platform support - Windows, Linux, and macOS</li> <li>\u2705 Layered configuration - Organization \u2192 Vendor \u2192 Recipe inheritance</li> <li>\u2705 PSADT packaging - Generate Intune-ready packages with PSAppDeployToolkit</li> <li>\ud83d\udea7 Direct Intune upload - Automatic deployment (planned)</li> <li>\ud83d\udea7 Deployment waves - Phased rollouts with rings (planned)</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Validate a recipe\nnapt validate recipes/Google/chrome.yaml\n\n# Discover version and download installer\nnapt discover recipes/Google/chrome.yaml\n\n# Build PSADT package\nnapt build recipes/Google/chrome.yaml\n\n# Create .intunewin package\nnapt package builds/napt-chrome/141.0.7390.123/\n</code></pre> <p>\ud83d\udca1 Tip: Add <code>--verbose</code> or <code>--debug</code> flags to any command for detailed output</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to get started? Check out the Quick Start Guide for installation instructions and your first steps with NAPT.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>NAPT uses a modular architecture with key design patterns:</p> <ul> <li>3-Layer Configuration - Organization \u2192 Vendor \u2192 Recipe inheritance with deep merging</li> <li>Strategy Pattern - Pluggable discovery strategies with version-first and file-first approaches</li> <li>Version-First Optimization - Skip downloads entirely when versions unchanged (url_regex, github_release, http_json)</li> <li>File-First Fallback - ETag-based conditional requests when version must be extracted from file (http_static)</li> <li>Cross-Platform - Native Windows support, Linux/macOS via msitools</li> </ul> <p>See the User Guide for detailed architecture information and the API Reference for code-level documentation.</p>"},{"location":"#cross-platform-support","title":"Cross-Platform Support","text":"Platform Download Config CLI MSI Extraction Status Windows \u2705 \u2705 \u2705 \u2705 Native (PowerShell COM) Fully Supported Linux \u2705 \u2705 \u2705 \u2705 Via msitools Fully Supported macOS \u2705 \u2705 \u2705 \u2705 Via msitools Fully Supported"},{"location":"#creating-recipes","title":"Creating Recipes","text":"<p>Recipes are declarative YAML files that define how to discover, download, and package applications.</p> <p>Example recipes:</p> <ul> <li>chrome.yaml - HTTP static strategy with MSI version extraction</li> <li>git.yaml - GitHub release strategy with asset pattern matching</li> <li>json-api-example.yaml - HTTP JSON API strategy</li> </ul> <p>Supported discovery strategies:</p> <ul> <li><code>http_static</code> - Fixed URLs, version from file</li> <li><code>url_regex</code> - Extract version from URL patterns</li> <li><code>github_release</code> - GitHub releases API</li> <li><code>http_json</code> - JSON API endpoints with JSONPath</li> </ul> <p>See the User Guide for detailed configuration reference and examples.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please ensure:</p> <ol> <li>Code follows existing patterns and conventions</li> <li>All functions have comprehensive docstrings</li> <li>Type annotations are included</li> <li>Tests are added for new features</li> <li>Documentation is updated</li> </ol> <p>See Contributing for detailed guidelines.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.</p>"},{"location":"#author","title":"Author","text":"<p>Roger Cibrian</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Built for automating Windows application deployment</li> <li>Uses PSAppDeployToolkit (PSADT) for packaging</li> <li>Targets Microsoft Intune for distribution</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to NAPT (Not a Pkg Tool) will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Discovery Performance Optimization - Version-first strategies (url_regex, github_release, http_json) now check versions before downloading, enabling instant to ~100ms update checks when unchanged instead of full downloads</li> <li>State file now saves actual download URLs for all strategies</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed ETag preservation bug causing alternating download/cached behavior in http_static strategy</li> </ul>"},{"location":"changelog/#020-2025-11-07","title":"0.2.0 - 2025-11-07","text":""},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#build-packaging","title":"Build &amp; Packaging","text":"<ul> <li>PSADT Package Generation with <code>napt build</code> command</li> <li>Automatic download and caching of PSAppDeployToolkit v4 templates</li> <li>Template customization with recipe install/uninstall scripts</li> <li>Version injection from state files for all discovery strategies</li> <li>Installer matching by app name/ID for accurate file selection</li> <li>Complete PSADT v4 structure with all required files</li> <li> <p>Custom branding support (icons, banners) from brand-packs</p> </li> <li> <p>.intunewin Package Creation with <code>napt package</code> command</p> </li> <li>Automatic download and caching of IntuneWinAppUtil.exe</li> <li>Integration with Microsoft's official packaging tool</li> <li>Build directory validation before packaging</li> <li>Ready-to-upload packages for Intune</li> </ul>"},{"location":"changelog/#discovery-strategies","title":"Discovery Strategies","text":"<ul> <li>GitHub Release Strategy (<code>github_release</code>)</li> <li>Automatic latest release detection from GitHub API</li> <li>Asset filtering by patterns</li> <li>Version extraction from release tags</li> <li> <p>ETag caching for efficient updates</p> </li> <li> <p>HTTP JSON Strategy (<code>http_json</code>)</p> </li> <li>JSON API endpoint parsing with JSONPath</li> <li>Flexible version and download URL extraction</li> <li> <p>Support for complex API responses</p> </li> <li> <p>URL Regex Strategy (<code>url_regex</code>)</p> </li> <li>Version extraction from URLs using regex</li> <li>Support for web scrapers and custom endpoints</li> <li>Flexible pattern matching</li> </ul>"},{"location":"changelog/#state-management","title":"State Management","text":"<ul> <li>State File Schema v2</li> <li>Convention-based file paths derived from URLs</li> <li>Metadata tracking (ETag, SHA-256, known_version)</li> <li>NAPT version tracking for compatibility</li> <li>Per-app state isolation</li> <li>Efficient re-runs with cached metadata</li> </ul>"},{"location":"changelog/#testing-infrastructure","title":"Testing Infrastructure","text":"<ul> <li>Hybrid Testing Strategy</li> <li>Unit tests with mocked/fake data for speed</li> <li>Integration tests with real PSADT templates</li> <li>Network-dependent tests marked appropriately</li> <li>Session-scoped fixtures for expensive operations</li> <li>Pytest markers (<code>@pytest.mark.unit</code>, <code>@pytest.mark.integration</code>, <code>@pytest.mark.network</code>)</li> </ul>"},{"location":"changelog/#documentation-project-management","title":"Documentation &amp; Project Management","text":"<ul> <li>docs/roadmap.md for tracking future features</li> <li>Categorized by status (Ideas, Investigating, Ready, Completed, Declined)</li> <li>Complexity and value assessments</li> <li>Technical considerations and blockers</li> <li> <p>Workspace rule for automatic updates</p> </li> <li> <p>Comprehensive Test Documentation</p> </li> <li>Testing philosophy and strategy explained</li> <li>Running tests by category</li> <li>Coverage guidelines and best practices</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>CLI Commands: Reorganized to reflect implemented vs. future commands</li> <li>Implemented: <code>validate</code>, <code>discover</code>, <code>build</code>, <code>package</code></li> <li> <p>Future: <code>upload</code>, <code>sync</code></p> </li> <li> <p>Recipe Format: Enhanced PSADT section</p> </li> <li><code>install</code> and <code>uninstall</code> blocks now generate PSADT v4 scripts</li> <li> <p>Support for PSAppDeployToolkit v4 cmdlets</p> </li> <li> <p>Sample Recipes: Updated to PSADT v4 best practices</p> </li> <li>Chrome: Uses <code>Start-ADTMsiProcess</code> and <code>Uninstall-ADTApplication</code></li> <li>Git: Uses <code>Start-ADTProcess</code> and <code>Uninstall-ADTApplication</code></li> <li> <p>JSON API examples: Updated with modern patterns</p> </li> <li> <p>Build Manager: State-based version fallback</p> </li> <li>Supports building apps discovered via any strategy</li> <li>Uses <code>known_version</code> from state when file extraction not available</li> <li> <p>Prioritizes installer matching by app name/ID</p> </li> <li> <p>Console Output: Removed Unicode characters for Windows compatibility</p> </li> <li>Replaced \u2713 with <code>[OK]</code></li> <li>Replaced \u2717 with <code>[ERROR]</code></li> <li>Replaced \u26a0 with <code>[WARNING]</code></li> <li>Replaced \u2192 with <code>-&gt;</code></li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>PSADT Template Handling</li> <li>Correctly identifies PSAppDeployToolkit_Template_v4.zip from releases</li> <li>Copies all required files from template root</li> <li> <p>Places Invoke-AppDeployToolkit.exe in correct location</p> </li> <li> <p>Branding Application</p> </li> <li>Fixed target path to use root Assets/ directory</li> <li> <p>Corrected Banner.Classic.png suffix handling</p> </li> <li> <p>Discovery Error Handling</p> </li> <li>Proper exception chaining with <code>from None</code></li> <li> <p>Convention-based cache file path derivation (schema v2)</p> </li> <li> <p>Version Extraction</p> </li> <li>SyntaxWarnings in regex patterns corrected</li> <li> <p>MSI ProductVersion extraction reliability improved</p> </li> <li> <p>Git Workflow</p> </li> <li>Git operations respect hooks and require explicit signing</li> <li>No automatic force-push or --no-verify flags</li> </ul>"},{"location":"changelog/#developer-experience","title":"Developer Experience","text":"<ul> <li>Workspace Rules</li> <li>PSADT reference documentation auto-loaded</li> <li>Git workflow conventions enforced</li> <li>Roadmap management automated</li> <li> <p>No backward compatibility required pre-1.0.0</p> </li> <li> <p>Code Quality</p> </li> <li>Ruff and Black integration in workflow</li> <li>Import organization and formatting automated</li> <li>Pytest configuration with strict markers</li> </ul>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<p>Note: NAPT has not been publicly released yet (0.1.0 was internal only). Breaking changes are acceptable until 1.0.0 release.</p> <ul> <li>State file schema changed to v2 (convention-based paths)</li> <li>Old state files will need to be regenerated</li> <li>CLI command structure finalized</li> </ul>"},{"location":"changelog/#010-2025-10-23","title":"0.1.0 - 2025-10-23","text":""},{"location":"changelog/#added_2","title":"Added","text":""},{"location":"changelog/#cli-core-functionality","title":"CLI &amp; Core Functionality","text":"<ul> <li>Recipe validation with <code>napt check</code> command</li> <li>Core orchestration for recipe \u2192 discover \u2192 download \u2192 extract workflow</li> <li>Command-line interface with argparse</li> <li>Verbose mode for detailed error tracebacks</li> <li>Structured result output for programmatic use</li> </ul>"},{"location":"changelog/#configuration-system","title":"Configuration System","text":"<ul> <li>Three-layer YAML configuration merging (organization \u2192 vendor \u2192 recipe)</li> <li>Deep merge for dictionaries with \"last wins\" semantics</li> <li>Automatic vendor detection from directory structure</li> <li>Relative path resolution for relocatable recipes</li> <li>Dynamic value injection (e.g., AppScriptDate)</li> </ul>"},{"location":"changelog/#discovery-strategies_1","title":"Discovery Strategies","text":"<ul> <li>Strategy pattern with protocol-based design</li> <li>Plugin registry for extensible discovery sources</li> <li>HTTP static URL strategy implementation</li> <li>Support for MSI ProductVersion extraction</li> </ul>"},{"location":"changelog/#version-management","title":"Version Management","text":"<ul> <li>Semantic versioning comparison with prerelease support</li> <li>MSI 3-part numeric version comparison</li> <li>EXE 4-part numeric version comparison</li> <li>Lexicographic fallback for non-standard formats</li> <li>Prerelease tag ordering (alpha &lt; beta &lt; rc)</li> <li>Chrome-style multi-part version support</li> </ul>"},{"location":"changelog/#download-infrastructure","title":"Download Infrastructure","text":"<ul> <li>Robust HTTP downloads with retry logic and exponential backoff</li> <li>Conditional requests using ETag and Last-Modified headers</li> <li>Atomic file writes (no partial downloads)</li> <li>SHA-256 integrity verification</li> <li>Content-Disposition header support</li> <li>Redirect following</li> <li>Stable ETag support (Accept-Encoding: identity)</li> </ul>"},{"location":"changelog/#msi-support","title":"MSI Support","text":"<ul> <li>Cross-platform MSI ProductVersion extraction</li> <li>Multiple backend support:</li> <li>Windows: msilib (stdlib), _msi (CPython extension), PowerShell COM</li> <li>Linux/macOS: msitools (msiinfo)</li> <li>Universal Windows support via PowerShell fallback</li> </ul>"},{"location":"changelog/#testing","title":"Testing","text":"<ul> <li>Comprehensive test suite with 61 tests</li> <li>100% pass rate</li> <li>Coverage for all major functionality</li> <li>Isolated tests with mocking (no network access)</li> <li>Tests run in &lt; 0.2 seconds</li> <li>Shared pytest fixtures</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete README with quick start guide</li> <li>MkDocs documentation site with user guide and API reference</li> <li>Auto-generated API documentation from docstrings</li> <li>Module-level docstrings with examples</li> <li>Test suite documentation</li> <li>Design rationale and decision explanations</li> <li>Cross-platform compatibility notes</li> </ul>"},{"location":"changelog/#technical-details","title":"Technical Details","text":""},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Python 3.11+ support</li> <li>PyYAML for configuration</li> <li>Requests for HTTP operations</li> <li>Poetry for dependency management</li> </ul>"},{"location":"changelog/#project-structure","title":"Project Structure","text":"<ul> <li>Modular package organization</li> <li>Protocol-based extensibility</li> <li>Type annotations throughout</li> <li>Modern Python 3.11+ syntax</li> <li>Consistent code style (Black + Ruff)</li> </ul>"},{"location":"changelog/#cross-platform-support","title":"Cross-Platform Support","text":"<ul> <li>\u2705 Windows (primary platform)</li> <li>\u2705 Linux (with msitools)</li> <li>\u2705 macOS (with msitools)</li> </ul>"},{"location":"changelog/#known-limitations","title":"Known Limitations","text":"<ul> <li>Only processes first app in multi-app recipes</li> <li>PSADT packaging not yet implemented</li> <li>Intune upload not yet implemented</li> <li>Deployment wave management not yet implemented</li> <li>Only http_static discovery strategy available</li> </ul>"},{"location":"changelog/#future-plans-030","title":"Future Plans (0.3.0+)","text":"<ul> <li>Additional discovery strategies (url_regex, github_release, http_json)</li> <li>PSADT package building</li> <li>.intunewin generation</li> <li>Microsoft Intune upload</li> <li>Deployment wave/ring management</li> <li>Update policy enforcement</li> </ul>"},{"location":"changelog/#release-notes","title":"Release Notes","text":"<p>This is the initial release of NAPT, providing a solid foundation for automating Windows application packaging workflows. The focus has been on building robust infrastructure for configuration management, version discovery, and file downloading.</p>"},{"location":"changelog/#what-works-now","title":"What Works Now","text":"<p>You can: - Validate recipes with <code>napt check</code> - Download installers automatically - Extract versions from MSI files - Compare versions intelligently - Use declarative YAML recipes</p>"},{"location":"changelog/#what-works-now_1","title":"What Works Now","text":"<p>With 0.2.0, you can: - Validate recipes with <code>napt validate</code> - Discover versions automatically with <code>napt discover</code> - Build PSADT packages with <code>napt build</code> - Create .intunewin packages with <code>napt package</code> - Use all four discovery strategies (http_static, github_release, http_json, url_regex) - Apply custom branding to deployments</p>"},{"location":"changelog/#whats-coming","title":"What's Coming","text":"<p>Future releases will add direct Intune upload, deployment wave management, and advanced validation features.</p>"},{"location":"contributing/","title":"Contributing to NAPT","text":"<p>Thank you for your interest in contributing to NAPT! This guide will help you get started.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone and install with dev dependencies\ngit clone https://github.com/RogerCibrian/notapkgtool.git\ncd notapkgtool\npoetry install\npoetry shell\n\n# Verify installation\nnapt --version\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npoetry run pytest tests/\n\n# Run only unit tests (fast)\npoetry run pytest tests/ -m \"not integration\"\n\n# Run with coverage\npoetry run pytest tests/ --cov=notapkgtool --cov-report=html\n</code></pre>"},{"location":"contributing/#code-quality","title":"Code Quality","text":"<pre><code># Format code\npoetry run black notapkgtool/ tests/\n\n# Fix linting issues\npoetry run ruff check --fix notapkgtool/ tests/\n\n# Check types (if using mypy)\npoetry run mypy notapkgtool/\n</code></pre>"},{"location":"contributing/#branching-strategy","title":"Branching Strategy","text":"<p>NAPT uses GitHub Flow - a simple, branch-based workflow that keeps <code>main</code> always deployable.</p>"},{"location":"contributing/#core-principles","title":"Core Principles","text":"<ol> <li><code>main</code> branch is always stable - Production-ready code only</li> <li>Feature branches for all work - Every change starts from a branch</li> <li>Pull Requests for review - All changes reviewed before merging</li> <li>Merge frequently - Keep branches short-lived (&lt; 1 week ideal)</li> </ol>"},{"location":"contributing/#branch-naming-convention","title":"Branch Naming Convention","text":"<p>Use descriptive names with type prefixes:</p> Prefix Purpose Example <code>feature/</code> New features or enhancements <code>feature/add-rpm-support</code> <code>bugfix/</code> Bug fixes <code>bugfix/fix-version-parsing</code> <code>docs/</code> Documentation updates <code>docs/update-installation-guide</code> <code>refactor/</code> Code improvements (no behavior change) <code>refactor/simplify-config-loader</code> <code>test/</code> Test additions/improvements <code>test/add-integration-tests</code> <code>chore/</code> Maintenance tasks <code>chore/update-dependencies</code> <code>hotfix/</code> Urgent production fixes <code>hotfix/security-patch</code> <p>Naming Rules:</p> <ul> <li>Use lowercase with hyphens</li> <li>Be descriptive but concise (3-6 words)</li> <li>Avoid generic names like <code>fix-bug</code> or <code>updates</code></li> <li>No issue numbers in branch names</li> </ul>"},{"location":"contributing/#workflow","title":"Workflow","text":""},{"location":"contributing/#starting-new-work","title":"Starting New Work","text":"<pre><code># Always start from updated main\ngit checkout main\ngit pull origin main\n\n# Create your feature branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#during-development","title":"During Development","text":"<pre><code># Make changes, commit frequently\ngit add .\ngit commit -m \"feat: add your feature\"\n\n# Push your branch\ngit push origin feature/your-feature-name\n</code></pre>"},{"location":"contributing/#creating-a-pull-request","title":"Creating a Pull Request","text":"<ol> <li>Push your branch to GitHub</li> <li>Create a Pull Request on GitHub</li> <li>Fill out the description with:</li> <li>What the PR does</li> <li>Why the change is needed</li> <li>How it was tested</li> <li>Request review from maintainers</li> <li>Address any feedback</li> </ol>"},{"location":"contributing/#after-merge","title":"After Merge","text":"<pre><code># Update your local main\ngit checkout main\ngit pull origin main\n\n# Delete your local feature branch\ngit branch -d feature/your-feature-name\n</code></pre>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commit format for clarity:</p> <pre><code>&lt;type&gt;: &lt;description&gt;\n\n[optional body]\n</code></pre>"},{"location":"contributing/#commit-types","title":"Commit Types","text":"Type Purpose Example <code>feat</code> New feature <code>feat: add EXE version extraction</code> <code>fix</code> Bug fix <code>fix: correct version comparison logic</code> <code>docs</code> Documentation <code>docs: update installation instructions</code> <code>refactor</code> Code improvement <code>refactor: simplify config loading</code> <code>test</code> Tests <code>test: add tests for MSI extraction</code> <code>chore</code> Maintenance <code>chore: update Poetry dependencies</code> <code>perf</code> Performance <code>perf: optimize version comparison</code>"},{"location":"contributing/#commit-guidelines","title":"Commit Guidelines","text":"<ul> <li>Use imperative mood: \"add\" not \"added\" or \"adds\"</li> <li>Keep subject line under 50 characters</li> <li>Capitalize subject line</li> <li>No period at end of subject</li> <li>Separate subject from body with blank line</li> </ul> <p>Good Examples:</p> <pre><code>git commit -m \"feat: add RPM version extraction support\"\ngit commit -m \"fix: handle missing ETag headers gracefully\"\ngit commit -m \"docs: add examples for Linux MSI extraction\"\n</code></pre>"},{"location":"contributing/#code-guidelines","title":"Code Guidelines","text":""},{"location":"contributing/#documentation-standards","title":"Documentation Standards","text":"<p>All code must include:</p> <ol> <li>Module-level docstrings - Explain purpose, features, and design decisions</li> <li>Function docstrings - Use Google-style format with:</li> <li>Summary</li> <li>Parameters section with types</li> <li>Returns section with type</li> <li>Raises section for exceptions</li> <li>Examples where helpful</li> <li>Type annotations - Full coverage for public APIs</li> <li>Comments - Explain \"why\" not \"what\"</li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Formatting: Use Black (line length 88)</li> <li>Linting: Pass Ruff checks</li> <li>Type hints: Modern Python 3.11+ syntax (<code>X | None</code>, not <code>Optional[X]</code>)</li> <li>Import order:</li> <li><code>from __future__ import annotations</code> (if needed)</li> <li>Standard library</li> <li>Third-party packages</li> <li>First-party (NAPT) imports</li> </ul>"},{"location":"contributing/#testing-requirements","title":"Testing Requirements","text":"<p>When adding new code:</p> <ol> <li>Write tests - All new features must have tests</li> <li>Mock external dependencies - Use requests-mock for HTTP, mock filesystem operations</li> <li>Test error cases - Not just happy paths</li> <li>Use fixtures - Leverage existing fixtures in <code>conftest.py</code></li> <li>Keep tests fast - Unit tests should run in milliseconds</li> <li>Mark integration tests - Use <code>@pytest.mark.integration</code> for tests with real dependencies</li> </ol>"},{"location":"contributing/#design-principles","title":"Design Principles","text":"<p>When contributing code:</p> <ol> <li>Follow existing patterns - Use the same style and structure as existing code</li> <li>Chain exceptions - Use <code>raise ... from err</code> for better debugging</li> <li>Return structured data - Functions return dicts/dataclasses for testing</li> <li>Single responsibility - Each function does one thing well</li> <li>Document design decisions - Explain \"why\" in docstrings</li> <li>Test cross-platform - Ensure Linux/Windows/macOS compatibility</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ul> <li>[ ] Code follows existing patterns and conventions</li> <li>[ ] All functions have comprehensive docstrings</li> <li>[ ] Type annotations are included</li> <li>[ ] Tests are added for new features</li> <li>[ ] All tests pass (<code>poetry run pytest tests/</code>)</li> <li>[ ] Code is formatted (<code>poetry run black notapkgtool/</code>)</li> <li>[ ] Linting passes (<code>poetry run ruff check --fix notapkgtool/</code>)</li> <li>[ ] Documentation is updated (README.md, docs/ if needed)</li> </ul>"},{"location":"contributing/#pr-description-template","title":"PR Description Template","text":"<pre><code>## Description\nBrief description of what this PR does.\n\n## Motivation\nWhy is this change needed?\n\n## Changes\n- Bullet list of key changes\n- Include any breaking changes\n\n## Testing\nHow was this tested?\n- [ ] Unit tests added/updated\n- [ ] Integration tests added/updated\n- [ ] Manual testing performed\n\n## Checklist\n- [ ] Code follows project conventions\n- [ ] Documentation updated\n- [ ] Tests pass\n- [ ] No linting errors\n</code></pre>"},{"location":"contributing/#questions-or-issues","title":"Questions or Issues?","text":"<ul> <li>Questions: Open a GitHub Discussion</li> <li>Bug Reports: Open a GitHub Issue with:</li> <li>NAPT version (<code>napt --version</code>)</li> <li>Python version</li> <li>Platform (Windows/Linux/macOS)</li> <li>Recipe file (or minimal example)</li> <li>Error message and traceback</li> <li>Steps to reproduce</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the GNU General Public License v3.0.</p>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with NAPT in minutes!</p>"},{"location":"quick-start/#installation","title":"Installation","text":""},{"location":"quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Git</li> </ul>"},{"location":"quick-start/#choose-your-installation-method","title":"Choose Your Installation Method","text":""},{"location":"quick-start/#option-1-poetry-recommended-for-development","title":"Option 1: Poetry (Recommended for Development)","text":"<p>Best for contributors and developers who want reproducible builds and dependency management.</p> <p>Prerequisites: Poetry must be installed. See Poetry Installation Guide</p> <pre><code># Clone and install\ngit clone https://github.com/RogerCibrian/notapkgtool.git\ncd notapkgtool\npoetry install\n\n# Activate virtual environment\npoetry shell\n\n# Verify installation\nnapt --version\n</code></pre> <p>Pros: Lock file for reproducibility, isolated environments, dev dependencies included</p>"},{"location":"quick-start/#option-2-pip-recommended-for-end-users","title":"Option 2: pip (Recommended for End Users)","text":"<p>Best for users who just want to use the tool without extra tooling.</p> <pre><code># Clone and install\ngit clone https://github.com/RogerCibrian/notapkgtool.git\ncd notapkgtool\npip install -e .\n\n# Verify installation\nnapt --version\n</code></pre> <p>Pros: No additional tools needed, familiar to all Python users</p>"},{"location":"quick-start/#platform-specific-requirements","title":"Platform-Specific Requirements","text":"<p>On Linux/macOS, install msitools for MSI version extraction:</p> <pre><code># Debian/Ubuntu\nsudo apt-get install msitools\n\n# RHEL/Fedora\nsudo dnf install msitools\n\n# macOS\nbrew install msitools\n</code></pre> <p>On Windows, no additional dependencies are required (uses PowerShell COM API for MSI extraction).</p>"},{"location":"quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"quick-start/#validate-a-recipe","title":"Validate a Recipe","text":"<p>Quick validation checks syntax and configuration without downloading anything:</p> <pre><code># Basic validation\nnapt validate recipes/Google/chrome.yaml\n\n# With verbose output\nnapt validate recipes/Google/chrome.yaml --verbose\n</code></pre>"},{"location":"quick-start/#discover-latest-version","title":"Discover Latest Version","text":"<p>Download the installer and extract version information:</p> <pre><code># Discover version and download installer\n# State tracking enabled by default for efficient re-runs\nnapt discover recipes/Google/chrome.yaml\n\n# Specify custom output directory\nnapt discover recipes/Google/chrome.yaml --output-dir ./cache\n\n# Show verbose output with progress details\nnapt discover recipes/Google/chrome.yaml --verbose\n\n# Disable state tracking (always download, no caching)\nnapt discover recipes/Google/chrome.yaml --stateless\n\n# Show debug output with full configuration dumps\nnapt discover recipes/Google/chrome.yaml --debug\n</code></pre>"},{"location":"quick-start/#build-psadt-package","title":"Build PSADT Package","text":"<p>Create a complete PSADT package ready for deployment:</p> <pre><code># Build PSADT package from recipe and downloaded installer\nnapt build recipes/Google/chrome.yaml\n\n# Specify custom downloads and output directories\nnapt build recipes/Google/chrome.yaml --downloads-dir ./downloads --output-dir ./builds\n\n# Show verbose output\nnapt build recipes/Google/chrome.yaml --verbose\n</code></pre>"},{"location":"quick-start/#create-intunewin-package","title":"Create .intunewin Package","text":"<p>Package the PSADT build for Microsoft Intune:</p> <pre><code># Create .intunewin from build directory\nnapt package builds/napt-chrome/141.0.7390.123/\n\n# Specify output directory and clean source after packaging\nnapt package builds/napt-chrome/141.0.7390.123/ --output-dir ./packages --clean-source\n</code></pre>"},{"location":"quick-start/#output-modes","title":"Output Modes","text":"<p>NAPT supports three verbosity levels:</p> Flag Mode Output (none) Normal Clean, minimal output with step indicators and progress bars <code>--verbose</code> Verbose Configuration details, HTTP info, file operations, SHA-256 hashes <code>--debug</code> Debug All verbose output plus full YAML config dumps and backend details <p>\ud83d\udca1 Tip: Add <code>--verbose</code> or <code>--debug</code> to any command for detailed output</p>"},{"location":"quick-start/#example-workflow","title":"Example Workflow","text":"<p>Here's a complete workflow from recipe validation to Intune package:</p> <pre><code># 1. Validate recipe\nnapt validate recipes/Google/chrome.yaml\n\n# 2. Discover and download latest version\nnapt discover recipes/Google/chrome.yaml\n\n# 3. Build PSADT package\nnapt build recipes/Google/chrome.yaml\n\n# 4. Create .intunewin package\nnapt package builds/napt-chrome/141.0.7390.123/\n\n# Result: Ready-to-upload .intunewin file in packages/napt-chrome/\n</code></pre>"},{"location":"quick-start/#whats-next","title":"What's Next?","text":"<p>Now that you have NAPT installed and understand the basic commands, explore:</p> <ul> <li>User Guide - Learn about discovery strategies, configuration, and advanced features</li> <li>API Reference - Use NAPT as a Python library</li> <li>Creating Recipes - Write your own application recipes</li> <li>Examples - Browse example recipes for Chrome, Git, and more</li> </ul>"},{"location":"roadmap/","title":"NAPT Roadmap","text":""},{"location":"roadmap/#philosophy","title":"Philosophy","text":"<p>This roadmap is a living document showing potential future directions for NAPT. Features listed here are ideas and possibilities, not commitments. Priorities may shift based on:</p> <ul> <li>User feedback and real-world usage</li> <li>Discovered technical challenges or opportunities</li> <li>New insights from development experience</li> <li>Community contributions</li> </ul> <p>Status Legend: - \ud83d\udca1 Idea: Unformed thought, needs refinement - \ud83d\udd2c Investigating: Researching feasibility/approach - \ud83d\udccb Ready: Well-defined, ready for implementation - \ud83d\udea7 In Progress: Actively being developed - \u2705 Completed: Implemented and released</p>"},{"location":"roadmap/#ideas-not-assigned-to-release","title":"Ideas (Not Assigned to Release)","text":""},{"location":"roadmap/#powershell-validation","title":"PowerShell Validation","text":"<p>Status: \ud83d\udca1 Idea Complexity: Medium (2-3 days) Value: High</p> <p>Description: Validate PowerShell syntax in recipe install/uninstall blocks to catch errors before deployment.</p> <p>Approach Options: - Basic structural checks (balanced braces, quotes) - PowerShell parser integration (PSParser tokenizer) - Hybrid: Basic checks + optional advanced validation</p> <p>Benefits: - Catch syntax errors at recipe validation time - Prevent broken deployments - Better developer experience</p> <p>Related: TODO in <code>notapkgtool/build/packager.py</code> - discovered during testing</p>"},{"location":"roadmap/#exe-version-extraction","title":"EXE Version Extraction","text":"<p>Status: \ud83d\udca1 Idea Complexity: Medium (2-3 days) Value: Medium</p> <p>Description: Extract version information from PE (Portable Executable) headers for .exe installers.</p> <p>Technical Details: - New version types: <code>exe_file_version</code>, <code>exe_product_version</code> - Use <code>pefile</code> library for cross-platform support - Fallback to PowerShell on Windows</p> <p>Use Cases: - Applications distributed as EXE (Git, VS Code, etc.) - Vendors who don't provide version in URL or API</p> <p>Related: Mentioned in <code>notapkgtool/discovery/http_static.py</code> docstring</p>"},{"location":"roadmap/#intunewinapputil-version-tracking","title":"IntuneWinAppUtil Version Tracking","text":"<p>Status: \ud83d\udca1 Idea Complexity: Low (1-2 days) Value: Low</p> <p>Description: Track version of IntuneWinAppUtil.exe in cache metadata instead of always using latest from master.</p> <p>Current Behavior: Downloads from <code>master</code> branch (always latest)</p> <p>Proposed Enhancement: - Track tool version in cache metadata - Allow pinning to specific commit/release - Auto-detect when tool updates available - Optional config setting for tool version/source</p> <p>Benefits: - Reproducible builds (pin to known-good version) - Control over tool updates - Better for air-gapped environments</p> <p>Related: TODO in <code>notapkgtool/build/packager.py:47</code></p>"},{"location":"roadmap/#recipe-linting-best-practices","title":"Recipe Linting &amp; Best Practices","text":"<p>Status: \ud83d\udca1 Idea Complexity: High (5+ days) Value: Medium</p> <p>Description: Advanced recipe validation beyond syntax checking.</p> <p>Features: - Validate PSADT function names exist in v4 - Warn on deprecated patterns or old v3 functions - Check for common anti-patterns - Suggest improvements (e.g., use Uninstall-ADTApplication) - Style guide enforcement</p> <p>Benefits: - Higher quality recipes - Consistent code style - Educational for new users</p>"},{"location":"roadmap/#parallel-package-building","title":"Parallel Package Building","text":"<p>Status: \ud83d\udca1 Idea Complexity: Medium (3-4 days) Value: Medium</p> <p>Description: Build multiple PSADT packages in parallel for faster multi-app workflows.</p> <p>Technical Details: - Use Python multiprocessing or asyncio - Parallel PSADT downloads and builds - Maintain state consistency - Progress reporting for multiple builds</p> <p>Use Cases: - Organizations with 50+ apps - Monthly update cycles - CI/CD pipelines</p>"},{"location":"roadmap/#detection-script-generation","title":"Detection Script Generation","text":"<p>Status: \ud83d\udca1 Idea Complexity: Medium (3-4 days) Value: High</p> <p>Description: Automatically generate detection scripts for Intune that check if an application is already installed.</p> <p>Approach Options: - For MSI: Generate script that checks ProductCode in registry - For EXE: Generate script that checks file version or registry keys - Template-based generation with recipe hints - Support for custom detection logic in recipes</p> <p>Benefits: - Reduces manual work for Intune app creation - Ensures consistent detection logic - Leverages information we already have (ProductCode, version, paths)</p> <p>Use Cases: - Automatic detection for Win32 apps in Intune - Prevent re-installation of already-installed apps - Version-based detection for upgrades</p> <p>Technical Considerations: - Need to handle both MSI and EXE installers - PowerShell detection script format for Intune - Support for custom registry keys or file paths - Version comparison in detection script</p>"},{"location":"roadmap/#prepost-installuninstall-script-support","title":"Pre/Post Install/Uninstall Script Support","text":"<p>Status: \ud83d\udca1 Idea Complexity: Low (1-2 days) Value: Medium</p> <p>Description: Add support for pre-install, post-install, pre-uninstall, and post-uninstall script blocks in recipes.</p> <p>Proposed Recipe Format:</p> <pre><code>psadt:\n  pre_install: |\n    # Close running processes\n    # Backup user data\n  install: |\n    # Main installation\n  post_install: |\n    # Configure settings\n    # Create shortcuts\n  pre_uninstall: |\n    # Backup settings\n  uninstall: |\n    # Main uninstallation\n  post_uninstall: |\n    # Clean up user data\n</code></pre> <p>Benefits: - More granular control over deployment lifecycle - Separation of concerns (prep vs install vs cleanup) - Aligns with PSADT's deployment phase structure - Cleaner recipe organization</p> <p>Implementation: - Add new fields to recipe schema - Insert into appropriate sections of Invoke-AppDeployToolkit.ps1 - Map to PSADT's Pre-Installation, Installation, Post-Installation sections - Validate all script blocks</p> <p>Related: PSADT already has these phases in the template structure</p>"},{"location":"roadmap/#enhanced-cli-help-menu","title":"Enhanced CLI Help Menu","text":"<p>Status: \ud83d\udca1 Idea Complexity: Low (1 day) Value: Medium</p> <p>Description: Improve the <code>napt -h</code> help output with more detailed information, examples, and better organization.</p> <p>Potential Enhancements: - Add examples for common workflows in help text - Group commands by category (Discovery, Building, Packaging) - Show performance characteristics of strategies - Add tips for troubleshooting (--verbose, --debug flags) - Include links to online documentation - Better formatting with colors/sections (via rich or similar)</p> <p>Benefits: - Better discoverability of features - Reduces need to consult docs for basic usage - Improves new user onboarding experience - Quick reference for command options</p> <p>Related: CLI help currently minimal, relies on online documentation</p>"},{"location":"roadmap/#investigating-research-phase","title":"Investigating (Research Phase)","text":""},{"location":"roadmap/#microsoft-intune-upload","title":"Microsoft Intune Upload","text":"<p>Status: \ud83d\udd2c Investigating Complexity: High (7-10 days) Value: Very High</p> <p>Description: Direct upload of .intunewin packages to Microsoft Intune via Graph API.</p> <p>Research Needed: - Authentication strategy (OAuth, service principal, managed identity?) - Graph API endpoints and permissions required - Win32 app metadata requirements - Error handling and retry logic - Rate limiting considerations</p> <p>Blockers: - Need to decide on authentication approach - Requires Azure AD app registration - May need different auth for different deployment scenarios</p> <p>References: - Microsoft Graph API - Win32 Apps - Intune App Upload Process</p>"},{"location":"roadmap/#deployment-wave-management","title":"Deployment Wave Management","text":"<p>Status: \ud83d\udd2c Investigating Complexity: Very High (10-15 days) Value: High</p> <p>Description: Phased deployment with rings (Pilot \u2192 Production) and gradual rollout.</p> <p>Features Under Consideration: - Ring definitions (Pilot, UAT, Production) - Assignment group management - Rollout scheduling (% of users per day) - Health monitoring integration - Rollback capabilities</p> <p>Dependencies: - Requires Intune upload implementation first - Requires Graph API for assignment groups - May need separate monitoring/alerting</p> <p>Blockers: - Complex domain requiring deep Intune knowledge - Needs real-world deployment patterns study</p>"},{"location":"roadmap/#ready-for-implementation","title":"Ready for Implementation","text":""},{"location":"roadmap/#update-policy-enforcement","title":"Update Policy Enforcement","text":"<p>Status: \ud83d\udccb Ready Complexity: Low (1-2 days) Value: Medium</p> <p>Description: Complete the <code>policy/updates.py</code> module with actual logic.</p> <p>Current State: Module exists with data structures, no implementation</p> <p>Requirements: - Implement version comparison logic - Implement hash comparison logic - Support all strategy types (version_only, hash_or_version, etc.) - Integration with state tracking</p> <p>Design: Already specified in <code>defaults/org.yaml</code> config</p>"},{"location":"roadmap/#completed","title":"Completed \u2705","text":""},{"location":"roadmap/#020-features","title":"0.2.0 Features","text":"<ul> <li>\u2705 PSADT package building (<code>napt build</code>)</li> <li>\u2705 .intunewin package creation (<code>napt package</code>)</li> <li>\u2705 PSADT Template_v4 download and caching</li> <li>\u2705 Invoke-AppDeployToolkit.ps1 generation</li> <li>\u2705 Custom branding support</li> <li>\u2705 GitHub releases discovery strategy</li> <li>\u2705 HTTP JSON API discovery strategy</li> <li>\u2705 URL regex discovery strategy</li> <li>\u2705 Integration testing framework</li> <li>\u2705 State schema v2 migration</li> </ul>"},{"location":"roadmap/#010-features","title":"0.1.0 Features","text":"<ul> <li>\u2705 Recipe validation</li> <li>\u2705 Version discovery</li> <li>\u2705 HTTP downloads with caching</li> <li>\u2705 MSI version extraction</li> <li>\u2705 Configuration system (3-layer merging)</li> </ul>"},{"location":"roadmap/#declined-wont-implement","title":"Declined / Won't Implement","text":""},{"location":"roadmap/#built-in-pr-creation","title":"Built-in PR Creation","text":"<p>Reason: NAPT should focus on discovery and packaging. Git operations and PR creation should remain in CI/CD workflows (GitHub Actions, etc.). This keeps NAPT platform-agnostic and focused on its core mission.</p> <p>Documentation: Documented in <code>.cursor/rules/napt-mission.mdc</code></p>"},{"location":"roadmap/#how-to-use-this-roadmap","title":"How to Use This Roadmap","text":""},{"location":"roadmap/#adding-new-ideas","title":"Adding New Ideas","text":"<ol> <li>Add to \"Ideas\" section with status \ud83d\udca1</li> <li>Include complexity estimate and value assessment</li> <li>Describe the problem it solves</li> <li>No need to design the solution yet</li> </ol>"},{"location":"roadmap/#promoting-ideas","title":"Promoting Ideas","text":"<p>When an idea becomes clearer: 1. Move to \"Investigating\" \ud83d\udd2c if research needed 2. Move to \"Ready for Implementation\" \ud83d\udccb when well-defined 3. Assign to milestone when scheduling work 4. Move to \"Completed\" when released</p>"},{"location":"roadmap/#declining-ideas","title":"Declining Ideas","text":"<p>If we decide not to pursue something: 1. Move to \"Declined / Won't Implement\" 2. Add brief rationale 3. Keep for future reference (prevents re-discussion)</p> <p>Last Updated: 2025-11-07 Next Review: After 0.2.0 release</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide covers NAPT's key features, configuration system, and advanced usage patterns.</p>"},{"location":"user-guide/#configuration-layers","title":"Configuration Layers","text":"<p>NAPT uses a sophisticated 3-layer configuration system that promotes DRY (Don't Repeat Yourself) principles:</p>"},{"location":"user-guide/#the-three-layers","title":"The Three Layers","text":"<ol> <li>Organization defaults (<code>defaults/org.yaml</code>) - Base configuration for all apps</li> <li>PSADT settings, update policies, deployment waves</li> <li> <p>Required if a defaults directory is found</p> </li> <li> <p>Vendor defaults (<code>defaults/vendors/&lt;Vendor&gt;.yaml</code>) - Vendor-specific overrides</p> </li> <li>Optional; only loaded if vendor is detected</li> <li> <p>Example: Google-specific settings</p> </li> <li> <p>Recipe configuration (<code>recipes/&lt;Vendor&gt;/&lt;app&gt;.yaml</code>) - App-specific settings</p> </li> <li>Always required; defines the specific app</li> <li>Final overrides</li> </ol>"},{"location":"user-guide/#merge-behavior","title":"Merge Behavior","text":"<p>The loader performs deep merging with \"last wins\" semantics:</p> <ul> <li>Dicts: Recursively merged (keys from overlay override base)</li> <li>Lists: Completely replaced (NOT appended/extended)</li> <li>Scalars: Overwritten (strings, numbers, booleans)</li> </ul>"},{"location":"user-guide/#example","title":"Example","text":"<pre><code># defaults/org.yaml\ndefaults:\n  psadt:\n    release: \"latest\"\n    app_vars:\n      AppVendor: \"Unknown\"\n</code></pre> <pre><code># defaults/vendors/Google.yaml\ndefaults:\n  psadt:\n    app_vars:\n      AppVendor: \"Google LLC\"\n</code></pre> <pre><code># recipes/Google/chrome.yaml\napps:\n  - name: \"Google Chrome\"\n    # AppVendor will be \"Google LLC\" (from vendor defaults)\n    # release will be \"latest\" (from org defaults)\n</code></pre>"},{"location":"user-guide/#state-management-caching","title":"State Management &amp; Caching","text":"<p>NAPT automatically tracks discovered versions and optimizes subsequent runs by avoiding unnecessary downloads.</p>"},{"location":"user-guide/#how-it-works","title":"How It Works","text":"<p>Version-First Strategies (url_regex, github_release, http_json):</p> <ol> <li>First Run: Discovers version, downloads file, saves version and hash to <code>state/versions.json</code></li> <li>Subsequent Runs: </li> <li>Discovers version (API call, regex, etc.)</li> <li>Compares to cached <code>known_version</code></li> <li>If match and file exists \u2192 Done! No download needed</li> <li>If different \u2192 Downloads new version</li> </ol> <p>File-First Strategy (http_static):</p> <ol> <li>First Run: Downloads file with ETag, extracts version, saves ETag to <code>state/versions.json</code></li> <li>Subsequent Runs:</li> <li>Makes conditional HTTP request with cached ETag (<code>If-None-Match</code> header)</li> <li>Server responds with <code>HTTP 304 Not Modified</code> \u2192 Uses cached file</li> <li>Server responds with <code>HTTP 200 OK</code> \u2192 Downloads new version, updates state</li> </ol>"},{"location":"user-guide/#default-behavior-stateful","title":"Default Behavior (Stateful)","text":"<pre><code># State tracking enabled by default\nnapt discover recipes/Google/chrome.yaml\n\n# Creates/updates: state/versions.json\n</code></pre>"},{"location":"user-guide/#stateless-mode","title":"Stateless Mode","text":"<pre><code># Disable state tracking for one-off checks\nnapt discover recipes/Google/chrome.yaml --stateless\n\n# Always downloads, no caching\n# Useful for CI/CD clean builds\n</code></pre>"},{"location":"user-guide/#benefits","title":"Benefits","text":"<ul> <li>Zero bandwidth: Version-first strategies skip downloads entirely when unchanged</li> <li>Speed: url_regex can be instant (no network calls), APIs ~100ms vs. downloading 60+ MB</li> <li>Server-friendly: Reduces load on vendor CDNs</li> <li>Cost savings: Critical for metered bandwidth and CI/CD with frequent checks</li> </ul>"},{"location":"user-guide/#discovery-strategies","title":"Discovery Strategies","text":"<p>Discovery strategies are the core mechanism for obtaining application installers and extracting version information.</p>"},{"location":"user-guide/#available-strategies","title":"Available Strategies","text":"Strategy Version Source Use Case Unchanged Check url_regex URL pattern Version-encoded URLs Instant (regex only) http_json JSON API REST APIs with metadata Fast (API call ~100ms) github_release Git tags GitHub-hosted releases Fast (GitHub API ~100ms) http_static File metadata Fixed URLs, MSI installers Medium (HTTP conditional ~500ms)"},{"location":"user-guide/#http_static","title":"http_static","text":"<p>Best for:</p> <ul> <li>Vendors with stable download URLs (Chrome, Firefox enterprise)</li> <li>MSI installers with ProductVersion embedded</li> <li>When version isn't in URL or easily parseable</li> </ul> <p>Configuration:</p> <pre><code>source:\n  strategy: http_static\n  url: \"https://dl.google.com/chrome/install/googlechromestandaloneenterprise64.msi\"\n  version:\n    type: msi_product_version_from_file\n</code></pre> <p>Pros: Simple and reliable, version directly from installer (most accurate) Cons: Must download file to know version, slower update checks (HTTP conditional request)</p>"},{"location":"user-guide/#url_regex","title":"url_regex","text":"<p>Best for:</p> <ul> <li>URLs with version numbers embedded (e.g., <code>app-v1.2.3.msi</code>)</li> <li>When version is in download URL path</li> <li>Fast version checks without downloads</li> </ul> <p>Configuration:</p> <pre><code>source:\n  strategy: url_regex\n  url: \"https://vendor.com/app-v1.2.3-setup.msi\"\n  version:\n    type: regex_in_url\n    pattern: \"app-v(?P&lt;version&gt;[0-9.]+)-setup\"\n</code></pre> <p>Pros: Know version before download, instant update checks (regex only, zero network), bandwidth-efficient Cons: Relies on URL format stability</p>"},{"location":"user-guide/#github_release","title":"github_release","text":"<p>Best for:</p> <ul> <li>Open-source projects on GitHub (Git, VS Code, Node.js)</li> <li>Projects with GitHub releases and release assets</li> <li>Semantic versioned tags</li> </ul> <p>Configuration:</p> <pre><code>source:\n  strategy: github_release\n  repo: \"git-for-windows/git\"\n  asset_pattern: \"Git-.*-64-bit\\\\.exe$\"\n  version_pattern: \"v?([0-9.]+)\"\n</code></pre> <p>Pros: Official GitHub API, reliable, fast update checks (API only, ~100ms), supports authentication Cons: GitHub API rate limits (60/hour unauthenticated)</p>"},{"location":"user-guide/#http_json","title":"http_json","text":"<p>Best for:</p> <ul> <li>Vendors with JSON REST APIs (Microsoft, Mozilla)</li> <li>Cloud services with version endpoints</li> <li>APIs requiring authentication or custom headers</li> </ul> <p>Configuration:</p> <pre><code>source:\n  strategy: http_json\n  api_url: \"https://vendor.com/api/latest\"\n  version_path: \"version\"\n  download_url_path: \"download_url\"\n  headers:\n    Authorization: \"Bearer ${API_TOKEN}\"\n</code></pre> <p>Pros: Fast update checks (API only, ~100ms), flexible, supports complex APIs, no file parsing Cons: Requires vendor API availability</p>"},{"location":"user-guide/#decision-guide","title":"Decision Guide","text":"<p>Use this flowchart to choose the right strategy:</p> <pre><code>Do you have a JSON API for version/download info?\n\u251c\u2500 YES \u2192 http_json (fast version checks, no download if unchanged)\n\u2514\u2500 NO  \u2192 Is the app on GitHub?\n    \u251c\u2500 YES \u2192 github_release (reliable API, fast checks)\n    \u2514\u2500 NO  \u2192 Is the version in the download URL?\n        \u251c\u2500 YES \u2192 url_regex (instant version checks!)\n        \u2514\u2500 NO  \u2192 http_static (must download to check)\n</code></pre> <p>Performance Note: Version-first strategies (everything except http_static) can skip downloads entirely when versions haven't changed, making them ideal for scheduled CI/CD checks.</p>"},{"location":"user-guide/#performance-characteristics","title":"Performance Characteristics","text":"<p>Understanding when each strategy excels:</p> <p>First Run (no cache):</p> <ul> <li>All strategies: ~same performance (must download installer)</li> <li>Difference: url_regex/APIs know version before downloading</li> </ul> <p>Scheduled Checks (version unchanged) - Most Common:</p> <ul> <li>url_regex: Instant (regex only, zero network calls)</li> <li>github_release: ~100ms (GitHub API call)</li> <li>http_json: ~100ms (vendor API call)</li> <li>http_static: ~500ms+ (conditional HTTP request to CDN)</li> </ul> <p>Version Changed:</p> <ul> <li>All strategies: Must download installer (~same performance)</li> </ul> <p>Recommendation: For CI/CD with scheduled checks, prefer version-first strategies (url_regex, github_release, http_json) when available. They can skip downloads entirely when nothing changed, dramatically reducing bandwidth and runtime.</p>"},{"location":"user-guide/#cross-platform-support","title":"Cross-Platform Support","text":"<p>NAPT works on Windows, Linux, and macOS with full feature parity.</p>"},{"location":"user-guide/#platform-compatibility-matrix","title":"Platform Compatibility Matrix","text":"Platform Download Config CLI MSI Extraction Status Windows \u2705 \u2705 \u2705 \u2705 Native (PowerShell COM) Fully Supported Linux \u2705 \u2705 \u2705 \u2705 Via msitools Fully Supported macOS \u2705 \u2705 \u2705 \u2705 Via msitools Fully Supported"},{"location":"user-guide/#msi-extraction-backends","title":"MSI Extraction Backends","text":"<p>Windows (tried in order):</p> <ol> <li><code>msilib</code> (Python standard library)</li> <li><code>_msi</code> (CPython extension)</li> <li>PowerShell COM (always available, universal fallback)</li> </ol> <p>Linux/macOS:</p> <ol> <li><code>msiinfo</code> from msitools package</li> </ol> <p>The PowerShell fallback makes MSI extraction truly universal on Windows systems, even when Python MSI libraries aren't available.</p>"},{"location":"user-guide/#commands-reference","title":"Commands Reference","text":""},{"location":"user-guide/#napt-validate","title":"napt validate","text":"<p>Validates recipe syntax and configuration without making network calls.</p> <pre><code>napt validate recipes/Google/chrome.yaml [--verbose]\n</code></pre> <p>Purpose:</p> <ul> <li>Quick feedback during recipe development</li> <li>CI/CD pre-checks</li> <li>Syntax validation</li> </ul> <p>What it checks:</p> <ul> <li>YAML syntax is valid</li> <li>Required fields present (apiVersion, apps, source)</li> <li>Discovery strategy exists and is registered</li> <li>Strategy-specific configuration is valid</li> </ul> <p>What it doesn't check:</p> <ul> <li>URLs are accessible</li> <li>Files can be downloaded</li> <li>Version extraction will work</li> </ul>"},{"location":"user-guide/#napt-discover","title":"napt discover","text":"<p>Discovers the latest version by downloading the installer and extracting version information.</p> <pre><code>napt discover recipes/Google/chrome.yaml [OPTIONS]\n\nOptions:\n  --output-dir DIR      Download directory (default: ./downloads)\n  --state-file FILE     State file path (default: state/versions.json)\n  --stateless           Disable state tracking\n  -v, --verbose         Show progress and status updates\n  -d, --debug           Show detailed debugging output\n</code></pre> <p>Features:</p> <ul> <li>\u2705 Discovers version using configured strategy</li> <li>\u2705 Downloads installer (or HTTP 304 if cached)</li> <li>\u2705 Extracts version from downloaded file</li> <li>\u2705 Updates state file with ETag caching</li> <li>\u2705 SHA-256 hash verification</li> </ul>"},{"location":"user-guide/#napt-build","title":"napt build","text":"<p>Builds a complete PSADT package from a recipe and downloaded installer.</p> <pre><code>napt build recipes/Google/chrome.yaml [OPTIONS]\n\nOptions:\n  --downloads-dir DIR   Installer directory (default: ./downloads)\n  --output-dir DIR      Build output directory (default: ./builds)\n  -v, --verbose         Show progress\n  -d, --debug           Show detailed output\n</code></pre> <p>Features:</p> <ul> <li>\u2705 Downloads PSADT release from GitHub (or uses cached version)</li> <li>\u2705 Extracts version from installer file</li> <li>\u2705 Generates Invoke-AppDeployToolkit.ps1 from template</li> <li>\u2705 Merges organization defaults with recipe-specific values</li> <li>\u2705 Inserts recipe install/uninstall code</li> <li>\u2705 Applies custom branding (logo, banner)</li> <li>\u2705 Creates versioned build directories</li> </ul>"},{"location":"user-guide/#napt-package","title":"napt package","text":"<p>Creates a .intunewin package from a built PSADT directory.</p> <pre><code>napt package BUILD_DIR [OPTIONS]\n\nOptions:\n  --output-dir DIR      Output directory (default: packages/{app_id}/)\n  --clean-source        Remove build directory after packaging\n  -v, --verbose         Show progress\n  -d, --debug           Show detailed output\n</code></pre> <p>Features:</p> <ul> <li>\u2705 Downloads IntuneWinAppUtil.exe (or uses cached version)</li> <li>\u2705 Validates build structure before packaging</li> <li>\u2705 Creates .intunewin file for Intune deployment</li> <li>\u2705 Optional source cleanup</li> </ul>"},{"location":"user-guide/#programmatic-api","title":"Programmatic API","text":"<p>NAPT can be used as a Python library for automation and integration.</p>"},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":"<pre><code>from pathlib import Path\nfrom notapkgtool.core import discover_recipe\nfrom notapkgtool.validation import validate_recipe\nfrom notapkgtool.config import load_effective_config\n\n# Validate recipe syntax (no downloads)\nresult = validate_recipe(\n    recipe_path=Path(\"recipes/Google/chrome.yaml\"),\n    verbose=True\n)\nprint(f\"Status: {result['status']}\")\n\n# Discover version and download installer\nresult = discover_recipe(\n    recipe_path=Path(\"recipes/Google/chrome.yaml\"),\n    output_dir=Path(\"./downloads\"),\n    verbose=True\n)\nprint(f\"Version: {result['version']}\")\nprint(f\"SHA-256: {result['sha256']}\")\n\n# Load configuration\nconfig = load_effective_config(Path(\"recipes/Google/chrome.yaml\"))\n</code></pre>"},{"location":"user-guide/#version-comparison","title":"Version Comparison","text":"<pre><code>from notapkgtool.versioning import compare_any, is_newer_any\n\n# Compare versions\nif is_newer_any(\"1.2.0\", \"1.1.9\"):\n    print(\"Update available!\")\n\n# Detailed comparison\nresult = compare_any(\"2.0.0\", \"1.9.9\")\n# Returns: 1 (newer), 0 (same), or -1 (older)\n</code></pre> <p>See the API Reference for complete documentation.</p>"},{"location":"user-guide/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/#recipe-organization","title":"Recipe Organization","text":"<pre><code>recipes/\n\u251c\u2500\u2500 &lt;Vendor&gt;/\n\u2502   \u251c\u2500\u2500 &lt;app1&gt;.yaml\n\u2502   \u251c\u2500\u2500 &lt;app2&gt;.yaml\n\u2502   \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"user-guide/#vendor-detection","title":"Vendor Detection","text":"<p>NAPT automatically detects vendor from directory structure:</p> <ul> <li><code>recipes/Google/chrome.yaml</code> \u2192 Vendor: \"Google\"</li> <li>Loads <code>defaults/vendors/Google.yaml</code> if it exists</li> </ul>"},{"location":"user-guide/#state-management","title":"State Management","text":"<p>For production use:</p> <ul> <li>\u2705 Keep state tracking enabled (default)</li> <li>\u2705 Use version control for state files</li> <li>\u2705 Run on schedule to detect updates</li> <li>\u2705 Use <code>--verbose</code> in CI/CD for debugging</li> </ul> <p>For development:</p> <ul> <li>Use <code>--stateless</code> for testing</li> <li>Use <code>--debug</code> for troubleshooting</li> <li>Delete state file to force re-discovery</li> </ul>"},{"location":"user-guide/#error-handling","title":"Error Handling","text":"<p>All commands return proper exit codes:</p> <ul> <li><code>0</code> = Success</li> <li><code>1</code> = Error (configuration, download, validation failure)</li> </ul> <p>Use in scripts:</p> <pre><code>if napt discover recipes/Google/chrome.yaml; then\n    napt build recipes/Google/chrome.yaml\nelse\n    echo \"Discovery failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"user-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/#common-issues","title":"Common Issues","text":"<p>Problem: \"Command not found: napt\"</p> <pre><code># Solution 1: Activate Poetry shell\npoetry shell\n\n# Solution 2: Use poetry run prefix\npoetry run napt --version\n</code></pre> <p>Problem: MSI extraction fails on Linux/macOS</p> <pre><code># Solution: Install msitools\nsudo apt-get install msitools  # Debian/Ubuntu\nbrew install msitools           # macOS\n</code></pre> <p>Problem: State file corrupted</p> <pre><code># NAPT automatically creates backup\n# Backup saved to: state/versions.json.backup\n\n# Force re-download\nnapt discover recipes/app.yaml --stateless\n</code></pre> <p>Problem: GitHub API rate limit</p> <pre><code># Solution: Use authentication token\n# In recipe:\nsource:\n  strategy: github_release\n  token: \"${GITHUB_TOKEN}\"\n\n# Set environment variable\nexport GITHUB_TOKEN=\"your_token_here\"\n</code></pre>"},{"location":"user-guide/#debug-mode","title":"Debug Mode","text":"<p>Always use <code>--debug</code> for troubleshooting:</p> <pre><code>napt discover recipes/Google/chrome.yaml --debug\n</code></pre> <p>This shows:</p> <ul> <li>Full configuration dumps</li> <li>HTTP request/response details</li> <li>Backend selection (MSI extraction method)</li> <li>File operations with paths</li> <li>Complete error tracebacks</li> </ul>"},{"location":"api/build/","title":"Build Module","text":"<p>The build module handles PSADT package creation and .intunewin packaging for Intune deployment.</p>"},{"location":"api/build/#build-manager","title":"Build Manager","text":""},{"location":"api/build/#notapkgtool.build.manager","title":"<code>notapkgtool.build.manager</code>","text":"<p>Build manager for PSADT package creation.</p> <p>This module orchestrates the complete build process for creating PSADT packages from recipes and downloaded installers.</p>"},{"location":"api/build/#notapkgtool.build.manager--functions","title":"Functions","text":"<p>build_package : function     Main entry point for building PSADT packages.</p>"},{"location":"api/build/#notapkgtool.build.manager--private-helpers","title":"Private Helpers","text":"<p>_get_installer_version : Extract version from downloaded installer _find_installer_file : Locate installer in downloads directory _create_build_directory : Create build directory structure _copy_psadt_pristine : Copy PSADT files from cache _copy_installer : Copy installer to Files/ directory _apply_branding : Replace PSADT assets with custom branding</p>"},{"location":"api/build/#notapkgtool.build.manager--design-principles","title":"Design Principles","text":"<ul> <li>Filesystem is source of truth for version information</li> <li>Entire PSADT Template_v4 structure copied pristine</li> <li>Invoke-AppDeployToolkit.ps1 is generated from template (not copied)</li> <li>Build directories are versioned: {app_id}/{version}/</li> <li>Branding applied by replacing files in root Assets/ directory (v4 structure)</li> </ul>"},{"location":"api/build/#notapkgtool.build.manager--example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom notapkgtool.build import build_package\n\nresult = build_package(\n    recipe_path=Path(\"recipes/Google/chrome.yaml\"),\n    downloads_dir=Path(\"downloads\"),\n)\n\nprint(f\"Built: {result['build_dir']}\")\n</code></pre>"},{"location":"api/build/#notapkgtool.build.manager.build_package","title":"<code>build_package(recipe_path, downloads_dir=None, output_dir=None, verbose=False, debug=False)</code>","text":"<p>Build a PSADT package from a recipe and downloaded installer.</p> <p>This is the main entry point for the build process. It:   1. Loads the recipe configuration   2. Finds the downloaded installer   3. Extracts version from installer (filesystem is truth)   4. Gets/downloads PSADT release   5. Creates build directory structure   6. Copies PSADT files (pristine)   7. Generates Invoke-AppDeployToolkit.ps1 from template   8. Copies installer to Files/   9. Applies custom branding</p>"},{"location":"api/build/#notapkgtool.build.manager.build_package--parameters","title":"Parameters","text":"<p>recipe_path : Path     Path to the recipe YAML file. downloads_dir : Path, optional     Directory containing the downloaded installer.     Default: Path(\"downloads\") output_dir : Path, optional     Base directory for build output.     Default: From config or Path(\"builds\") verbose : bool, optional     Show verbose progress output. debug : bool, optional     Show debug output.</p>"},{"location":"api/build/#notapkgtool.build.manager.build_package--returns","title":"Returns","text":"<p>dict     Build results containing:     - app_id : str     - app_name : str     - version : str     - build_dir : Path     - psadt_version : str     - status : str</p>"},{"location":"api/build/#notapkgtool.build.manager.build_package--raises","title":"Raises","text":"<p>FileNotFoundError     If recipe or installer doesn't exist. RuntimeError     If build process fails.</p>"},{"location":"api/build/#notapkgtool.build.manager.build_package--examples","title":"Examples","text":"<p>Basic build:</p> <pre><code>&gt;&gt;&gt; result = build_package(Path(\"recipes/Google/chrome.yaml\"))\n&gt;&gt;&gt; print(result['build_dir'])\nbuilds/napt-chrome/141.0.7390.123\n</code></pre> <p>Custom output directory:</p> <pre><code>&gt;&gt;&gt; result = build_package(\n...     Path(\"recipes/Google/chrome.yaml\"),\n...     output_dir=Path(\"custom/builds\")\n... )\n</code></pre>"},{"location":"api/build/#notapkgtool.build.manager.build_package--notes","title":"Notes","text":"<ul> <li>Requires installer to be downloaded first (run 'napt discover')</li> <li>Version extracted from installer file, not state cache</li> <li>Overwrites existing build directory if it exists</li> <li>PSADT files are copied pristine from cache</li> <li>Invoke-AppDeployToolkit.ps1 is generated (not copied)</li> </ul> Source code in <code>notapkgtool/build/manager.py</code> <pre><code>def build_package(\n    recipe_path: Path,\n    downloads_dir: Path | None = None,\n    output_dir: Path | None = None,\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Build a PSADT package from a recipe and downloaded installer.\n\n    This is the main entry point for the build process. It:\n      1. Loads the recipe configuration\n      2. Finds the downloaded installer\n      3. Extracts version from installer (filesystem is truth)\n      4. Gets/downloads PSADT release\n      5. Creates build directory structure\n      6. Copies PSADT files (pristine)\n      7. Generates Invoke-AppDeployToolkit.ps1 from template\n      8. Copies installer to Files/\n      9. Applies custom branding\n\n    Parameters\n    ----------\n    recipe_path : Path\n        Path to the recipe YAML file.\n    downloads_dir : Path, optional\n        Directory containing the downloaded installer.\n        Default: Path(\"downloads\")\n    output_dir : Path, optional\n        Base directory for build output.\n        Default: From config or Path(\"builds\")\n    verbose : bool, optional\n        Show verbose progress output.\n    debug : bool, optional\n        Show debug output.\n\n    Returns\n    -------\n    dict\n        Build results containing:\n        - app_id : str\n        - app_name : str\n        - version : str\n        - build_dir : Path\n        - psadt_version : str\n        - status : str\n\n    Raises\n    ------\n    FileNotFoundError\n        If recipe or installer doesn't exist.\n    RuntimeError\n        If build process fails.\n\n    Examples\n    --------\n    Basic build:\n\n        &gt;&gt;&gt; result = build_package(Path(\"recipes/Google/chrome.yaml\"))\n        &gt;&gt;&gt; print(result['build_dir'])\n        builds/napt-chrome/141.0.7390.123\n\n    Custom output directory:\n\n        &gt;&gt;&gt; result = build_package(\n        ...     Path(\"recipes/Google/chrome.yaml\"),\n        ...     output_dir=Path(\"custom/builds\")\n        ... )\n\n    Notes\n    -----\n    - Requires installer to be downloaded first (run 'napt discover')\n    - Version extracted from installer file, not state cache\n    - Overwrites existing build directory if it exists\n    - PSADT files are copied pristine from cache\n    - Invoke-AppDeployToolkit.ps1 is generated (not copied)\n    \"\"\"\n    from notapkgtool.cli import print_step, print_verbose\n\n    # Load configuration\n    print_step(1, 6, \"Loading configuration...\")\n    config = load_effective_config(recipe_path, verbose=verbose, debug=debug)\n\n    app = config[\"apps\"][0]\n    app_id = app.get(\"id\", \"unknown-app\")\n    app_name = app.get(\"name\", \"Unknown App\")\n\n    # Set defaults\n    if downloads_dir is None:\n        downloads_dir = Path(\"downloads\")\n\n    if output_dir is None:\n        output_dir = Path(\n            config.get(\"defaults\", {}).get(\"build\", {}).get(\"output_dir\", \"builds\")\n        )\n\n    # Find installer file\n    print_step(2, 6, \"Finding installer...\")\n    installer_file = _find_installer_file(downloads_dir, config)\n\n    # Extract version from installer or state (filesystem + state are truth)\n    print_step(3, 6, \"Extracting version from installer...\")\n    state_file = Path(\"state/versions.json\")  # Default state file location\n    version = _get_installer_version(installer_file, config, state_file)\n\n    print_verbose(\"BUILD\", f\"Building {app_name} v{version}\")\n\n    # Get PSADT release\n    print_step(4, 6, \"Getting PSADT release...\")\n    psadt_config = config.get(\"defaults\", {}).get(\"psadt\", {})\n    release_spec = psadt_config.get(\"release\", \"latest\")\n    cache_dir = Path(psadt_config.get(\"cache_dir\", \"cache/psadt\"))\n\n    psadt_cache_dir = get_psadt_release(\n        release_spec, cache_dir, verbose=verbose, debug=debug\n    )\n    psadt_version = psadt_cache_dir.name  # Directory name is the version\n\n    print_verbose(\"BUILD\", f\"Using PSADT {psadt_version}\")\n\n    # Create build directory\n    print_step(5, 6, \"Creating build structure...\")\n    build_dir = _create_build_directory(output_dir, app_id, version)\n\n    # Copy PSADT files (pristine)\n    _copy_psadt_pristine(psadt_cache_dir, build_dir)\n\n    # Generate Invoke-AppDeployToolkit.ps1\n    from .template import generate_invoke_script\n\n    template_path = psadt_cache_dir / \"Invoke-AppDeployToolkit.ps1\"\n    invoke_script = generate_invoke_script(\n        template_path, config, version, psadt_version, verbose=verbose, debug=debug\n    )\n\n    # Write generated script\n    script_dest = build_dir / \"Invoke-AppDeployToolkit.ps1\"\n    script_dest.write_text(invoke_script, encoding=\"utf-8\")\n    print_verbose(\"BUILD\", \"[OK] Generated Invoke-AppDeployToolkit.ps1\")\n\n    # Copy installer\n    _copy_installer(installer_file, build_dir)\n\n    # Apply branding\n    print_step(6, 6, \"Applying branding...\")\n    _apply_branding(config, build_dir)\n\n    print_verbose(\"BUILD\", f\"[OK] Build complete: {build_dir}\")\n\n    return {\n        \"app_id\": app_id,\n        \"app_name\": app_name,\n        \"version\": version,\n        \"build_dir\": build_dir,\n        \"psadt_version\": psadt_version,\n        \"status\": \"success\",\n    }\n</code></pre>"},{"location":"api/build/#template-generation","title":"Template Generation","text":""},{"location":"api/build/#notapkgtool.build.template","title":"<code>notapkgtool.build.template</code>","text":"<p>Invoke-AppDeployToolkit.ps1 template generation for NAPT.</p> <p>This module handles generating the Invoke-AppDeployToolkit.ps1 script by reading PSADT's template, substituting configuration values, and inserting recipe-specific install/uninstall code.</p>"},{"location":"api/build/#notapkgtool.build.template--functions","title":"Functions","text":"<p>generate_invoke_script : function     Main entry point for script generation.</p>"},{"location":"api/build/#notapkgtool.build.template--private-helpers","title":"Private Helpers","text":"<p>_build_adtsession_vars : Build $adtSession hashtable from config _replace_session_block : Replace $adtSession = @{...} in template _insert_recipe_code : Insert install/uninstall code at markers _format_powershell_value : Format Python values as PowerShell literals</p>"},{"location":"api/build/#notapkgtool.build.template--design-principles","title":"Design Principles","text":"<ul> <li>PSADT template remains pristine in cache</li> <li>Generate script by substitution, not modification</li> <li>Preserve PSADT's structure and comments</li> <li>Support dynamic values (AppScriptDate, discovered version)</li> <li>Merge org defaults with recipe overrides</li> </ul>"},{"location":"api/build/#notapkgtool.build.template--example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom notapkgtool.build.template import generate_invoke_script\n\nscript = generate_invoke_script(\n    template_path=Path(\"cache/psadt/4.1.7/Invoke-AppDeployToolkit.ps1\"),\n    config=recipe_config,\n    version=\"141.0.7390.123\",\n    psadt_version=\"4.1.7\"\n)\n\nPath(\"builds/app/version/Invoke-AppDeployToolkit.ps1\").write_text(script)\n</code></pre>"},{"location":"api/build/#notapkgtool.build.template.generate_invoke_script","title":"<code>generate_invoke_script(template_path, config, version, psadt_version, verbose=False, debug=False)</code>","text":"<p>Generate Invoke-AppDeployToolkit.ps1 from PSADT template and config.</p> <p>Reads the PSADT template, replaces the $adtSession hashtable with values from the configuration, and inserts recipe-specific install/ uninstall code.</p>"},{"location":"api/build/#notapkgtool.build.template.generate_invoke_script--parameters","title":"Parameters","text":"<p>template_path : Path     Path to PSADT's Invoke-AppDeployToolkit.ps1 template. config : dict     Merged configuration (org + vendor + recipe). version : str     Application version (from filesystem). psadt_version : str     PSADT version being used. verbose : bool, optional     Show verbose output. debug : bool, optional     Show debug output.</p>"},{"location":"api/build/#notapkgtool.build.template.generate_invoke_script--returns","title":"Returns","text":"<p>str     Generated PowerShell script text.</p>"},{"location":"api/build/#notapkgtool.build.template.generate_invoke_script--raises","title":"Raises","text":"<p>FileNotFoundError     If template doesn't exist. RuntimeError     If template parsing fails.</p>"},{"location":"api/build/#notapkgtool.build.template.generate_invoke_script--examples","title":"Examples","text":"<p>script = generate_invoke_script( ...     Path(\"cache/psadt/4.1.7/Invoke-AppDeployToolkit.ps1\"), ...     config, ...     \"141.0.7390.123\", ...     \"4.1.7\" ... )</p> Source code in <code>notapkgtool/build/template.py</code> <pre><code>def generate_invoke_script(\n    template_path: Path,\n    config: dict[str, Any],\n    version: str,\n    psadt_version: str,\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; str:\n    \"\"\"\n    Generate Invoke-AppDeployToolkit.ps1 from PSADT template and config.\n\n    Reads the PSADT template, replaces the $adtSession hashtable with\n    values from the configuration, and inserts recipe-specific install/\n    uninstall code.\n\n    Parameters\n    ----------\n    template_path : Path\n        Path to PSADT's Invoke-AppDeployToolkit.ps1 template.\n    config : dict\n        Merged configuration (org + vendor + recipe).\n    version : str\n        Application version (from filesystem).\n    psadt_version : str\n        PSADT version being used.\n    verbose : bool, optional\n        Show verbose output.\n    debug : bool, optional\n        Show debug output.\n\n    Returns\n    -------\n    str\n        Generated PowerShell script text.\n\n    Raises\n    ------\n    FileNotFoundError\n        If template doesn't exist.\n    RuntimeError\n        If template parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; script = generate_invoke_script(\n    ...     Path(\"cache/psadt/4.1.7/Invoke-AppDeployToolkit.ps1\"),\n    ...     config,\n    ...     \"141.0.7390.123\",\n    ...     \"4.1.7\"\n    ... )\n    \"\"\"\n    from notapkgtool.cli import print_debug, print_verbose\n\n    if not template_path.exists():\n        raise FileNotFoundError(f\"PSADT template not found: {template_path}\")\n\n    print_verbose(\"BUILD\", f\"Reading PSADT template: {template_path.name}\")\n\n    # Read template\n    template = template_path.read_text(encoding=\"utf-8\")\n\n    # Build $adtSession variables\n    print_verbose(\"BUILD\", \"Building $adtSession variables...\")\n    session_vars = _build_adtsession_vars(config, version, psadt_version)\n\n    if debug:\n        print_debug(\"BUILD\", \"--- $adtSession Variables ---\")\n        for key, value in session_vars.items():\n            print_debug(\"BUILD\", f\"  {key} = {value}\")\n\n    # Replace $adtSession block\n    script = _replace_session_block(template, session_vars)\n    print_verbose(\"BUILD\", \"[OK] Replaced $adtSession hashtable\")\n\n    # Insert recipe code\n    app = config[\"apps\"][0]\n    psadt_config = app.get(\"psadt\", {})\n    install_code = psadt_config.get(\"install\")\n    uninstall_code = psadt_config.get(\"uninstall\")\n\n    if install_code:\n        print_verbose(\"BUILD\", \"Inserting install code from recipe\")\n    if uninstall_code:\n        print_verbose(\"BUILD\", \"Inserting uninstall code from recipe\")\n\n    script = _insert_recipe_code(script, install_code, uninstall_code)\n\n    print_verbose(\"BUILD\", \"[OK] Script generation complete\")\n\n    return script\n</code></pre>"},{"location":"api/build/#packager","title":"Packager","text":""},{"location":"api/build/#notapkgtool.build.packager","title":"<code>notapkgtool.build.packager</code>","text":"<p>.intunewin package generation for NAPT.</p> <p>This module handles creating .intunewin packages from built PSADT directories using Microsoft's IntuneWinAppUtil.exe tool.</p>"},{"location":"api/build/#notapkgtool.build.packager--functions","title":"Functions","text":"<p>create_intunewin : function     Create a .intunewin package from a PSADT build directory.</p>"},{"location":"api/build/#notapkgtool.build.packager--private-helpers","title":"Private Helpers","text":"<p>_get_intunewin_tool : Download and cache IntuneWinAppUtil.exe _execute_packaging : Run IntuneWinAppUtil.exe to create .intunewin _verify_build_structure : Validate PSADT build directory</p>"},{"location":"api/build/#notapkgtool.build.packager--design-principles","title":"Design Principles","text":"<ul> <li>IntuneWinAppUtil.exe is cached globally (not per-build)</li> <li>Package output follows convention: {app_id}-{version}.intunewin</li> <li>Build directory can optionally be cleaned after packaging</li> <li>Tool is downloaded from Microsoft's official GitHub repository</li> </ul>"},{"location":"api/build/#notapkgtool.build.packager--example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom notapkgtool.build.packager import create_intunewin\n\nresult = create_intunewin(\n    build_dir=Path(\"builds/napt-chrome/141.0.7390.123\"),\n    output_dir=Path(\"packages\")\n)\n\nprint(f\"Package: {result['package_path']}\")\n</code></pre>"},{"location":"api/build/#notapkgtool.build.packager.create_intunewin","title":"<code>create_intunewin(build_dir, output_dir=None, clean_source=False, verbose=False, debug=False)</code>","text":"<p>Create a .intunewin package from a PSADT build directory.</p> <p>Uses Microsoft's IntuneWinAppUtil.exe tool to package a PSADT build directory into a .intunewin file suitable for Intune deployment.</p>"},{"location":"api/build/#notapkgtool.build.packager.create_intunewin--parameters","title":"Parameters","text":"<p>build_dir : Path     Path to the built PSADT package directory. output_dir : Path, optional     Directory for the .intunewin output.     Default: packages/{app_id}/ clean_source : bool, optional     If True, remove the build directory after packaging.     Default: False. verbose : bool, optional     Show verbose output. debug : bool, optional     Show debug output.</p>"},{"location":"api/build/#notapkgtool.build.packager.create_intunewin--returns","title":"Returns","text":"<p>dict     Packaging results containing:     - build_dir : Path     - package_path : Path     - app_id : str (from directory structure)     - version : str (from directory structure)     - status : str</p>"},{"location":"api/build/#notapkgtool.build.packager.create_intunewin--raises","title":"Raises","text":"<p>ValueError     If build directory structure is invalid. RuntimeError     If packaging fails.</p>"},{"location":"api/build/#notapkgtool.build.packager.create_intunewin--examples","title":"Examples","text":"<p>Basic packaging:</p> <pre><code>&gt;&gt;&gt; result = create_intunewin(\n...     build_dir=Path(\"builds/napt-chrome/141.0.7390.123\")\n... )\n&gt;&gt;&gt; print(result['package_path'])\npackages/napt-chrome/napt-chrome-141.0.7390.123.intunewin\n</code></pre> <p>With cleanup:</p> <pre><code>&gt;&gt;&gt; result = create_intunewin(\n...     build_dir=Path(\"builds/napt-chrome/141.0.7390.123\"),\n...     clean_source=True\n... )\n# Build directory is removed after packaging\n</code></pre>"},{"location":"api/build/#notapkgtool.build.packager.create_intunewin--notes","title":"Notes","text":"<ul> <li>Requires build directory from 'napt build' command</li> <li>IntuneWinAppUtil.exe is downloaded and cached on first use</li> <li>Setup file is always \"Invoke-AppDeployToolkit.exe\"</li> <li>Output follows convention: packages/{app_id}/{app_id}-{version}.intunewin</li> </ul> Source code in <code>notapkgtool/build/packager.py</code> <pre><code>def create_intunewin(\n    build_dir: Path,\n    output_dir: Path | None = None,\n    clean_source: bool = False,\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Create a .intunewin package from a PSADT build directory.\n\n    Uses Microsoft's IntuneWinAppUtil.exe tool to package a PSADT build\n    directory into a .intunewin file suitable for Intune deployment.\n\n    Parameters\n    ----------\n    build_dir : Path\n        Path to the built PSADT package directory.\n    output_dir : Path, optional\n        Directory for the .intunewin output.\n        Default: packages/{app_id}/\n    clean_source : bool, optional\n        If True, remove the build directory after packaging.\n        Default: False.\n    verbose : bool, optional\n        Show verbose output.\n    debug : bool, optional\n        Show debug output.\n\n    Returns\n    -------\n    dict\n        Packaging results containing:\n        - build_dir : Path\n        - package_path : Path\n        - app_id : str (from directory structure)\n        - version : str (from directory structure)\n        - status : str\n\n    Raises\n    ------\n    ValueError\n        If build directory structure is invalid.\n    RuntimeError\n        If packaging fails.\n\n    Examples\n    --------\n    Basic packaging:\n\n        &gt;&gt;&gt; result = create_intunewin(\n        ...     build_dir=Path(\"builds/napt-chrome/141.0.7390.123\")\n        ... )\n        &gt;&gt;&gt; print(result['package_path'])\n        packages/napt-chrome/napt-chrome-141.0.7390.123.intunewin\n\n    With cleanup:\n\n        &gt;&gt;&gt; result = create_intunewin(\n        ...     build_dir=Path(\"builds/napt-chrome/141.0.7390.123\"),\n        ...     clean_source=True\n        ... )\n        # Build directory is removed after packaging\n\n    Notes\n    -----\n    - Requires build directory from 'napt build' command\n    - IntuneWinAppUtil.exe is downloaded and cached on first use\n    - Setup file is always \"Invoke-AppDeployToolkit.exe\"\n    - Output follows convention: packages/{app_id}/{app_id}-{version}.intunewin\n    \"\"\"\n    from notapkgtool.cli import print_step, print_verbose\n\n    build_dir = build_dir.resolve()\n\n    if not build_dir.exists():\n        raise FileNotFoundError(f\"Build directory not found: {build_dir}\")\n\n    # Extract app_id and version from directory structure (app_id/version/)\n    version = build_dir.name\n    app_id = build_dir.parent.name\n\n    print_verbose(\"PACKAGE\", f\"Packaging {app_id} v{version}\")\n\n    # Verify build structure\n    print_step(1, 4, \"Verifying build structure...\")\n    _verify_build_structure(build_dir)\n\n    # Determine output directory\n    if output_dir is None:\n        output_dir = Path(\"packages\") / app_id\n\n    output_dir = output_dir.resolve()\n\n    # Get IntuneWinAppUtil tool\n    print_step(2, 4, \"Getting IntuneWinAppUtil tool...\")\n    tool_cache = Path(\"cache/tools\")\n    tool_path = _get_intunewin_tool(tool_cache, verbose=verbose)\n\n    # Create .intunewin package\n    print_step(3, 4, \"Creating .intunewin package...\")\n    package_path = _execute_packaging(\n        tool_path,\n        build_dir,\n        \"Invoke-AppDeployToolkit.exe\",\n        output_dir,\n        verbose=verbose,\n    )\n\n    # Optionally clean source\n    if clean_source:\n        print_step(4, 4, \"Cleaning source build directory...\")\n        shutil.rmtree(build_dir)\n        print_verbose(\"PACKAGE\", f\"[OK] Removed build directory: {build_dir}\")\n    else:\n        print_step(4, 4, \"Package complete\")\n\n    print_verbose(\"PACKAGE\", f\"[OK] Package created: {package_path}\")\n\n    return {\n        \"build_dir\": build_dir,\n        \"package_path\": package_path,\n        \"app_id\": app_id,\n        \"version\": version,\n        \"status\": \"success\",\n    }\n</code></pre>"},{"location":"api/config/","title":"Configuration Module","text":"<p>The configuration module implements the three-layer configuration system with deep merging and path resolution.</p>"},{"location":"api/config/#notapkgtool.config","title":"<code>notapkgtool.config</code>","text":"<p>Configuration loading and management for NAPT.</p> <p>This module provides tools for loading, merging, and validating YAML-based configuration files with a layered approach:   - Organization-wide defaults (defaults/org.yaml)   - Vendor-specific defaults (defaults/vendors/.yaml)   - Recipe-specific configuration (recipes//.yaml) <p>The loader performs deep merging where dicts are merged recursively and lists/scalars are replaced (last wins). Relative paths are resolved against the recipe file location for relocatability.</p>"},{"location":"api/config/#notapkgtool.config--public-api","title":"Public API","text":"<p>load_effective_config : function     Load and merge configuration for a recipe.</p>"},{"location":"api/config/#notapkgtool.config--example","title":"Example","text":"<pre><code>from pathlib import Path\nfrom notapkgtool.config import load_effective_config\n\nconfig = load_effective_config(Path(\"recipes/Google/chrome.yaml\"))\nprint(config[\"apps\"][0][\"name\"])  # \"Google Chrome\"\n</code></pre>"},{"location":"api/config/#notapkgtool.config.load_effective_config","title":"<code>load_effective_config(recipe_path, *, vendor=None, verbose=False, debug=False)</code>","text":"<p>Load and merge the effective configuration for a recipe.</p> <p>Steps   1) Read recipe YAML.   2) Find defaults root by scanning upwards for 'defaults/org.yaml'.   3) Load org defaults (required if defaults root exists).   4) Determine vendor (param 'vendor' &gt; folder name &gt; recipe contents).   5) Load vendor defaults if present.   6) Merge: org -&gt; vendor -&gt; recipe (dicts deep-merge, lists replace).   7) Resolve known relative paths (relative to the recipe directory).   8) Inject dynamic fields (AppScriptDate = today if absent).</p> <p>Returns   A merged configuration dict ready for downstream processors.   If no defaults were found in the tree, the recipe is returned as-is (with path resolution + injection).</p> <p>Raises   SystemExit on YAML parse errors (with chained context),   FileNotFoundError if the recipe file itself is missing.</p> Source code in <code>notapkgtool/config/loader.py</code> <pre><code>def load_effective_config(\n    recipe_path: Path,\n    *,\n    vendor: str | None = None,\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Load and merge the effective configuration for a recipe.\n\n    Steps\n      1) Read recipe YAML.\n      2) Find defaults root by scanning upwards for 'defaults/org.yaml'.\n      3) Load org defaults (required if defaults root exists).\n      4) Determine vendor (param 'vendor' &gt; folder name &gt; recipe contents).\n      5) Load vendor defaults if present.\n      6) Merge: org -&gt; vendor -&gt; recipe (dicts deep-merge, lists replace).\n      7) Resolve known relative paths (relative to the recipe directory).\n      8) Inject dynamic fields (AppScriptDate = today if absent).\n\n    Returns\n      A merged configuration dict ready for downstream processors.\n      If no defaults were found in the tree, the recipe is returned as-is (with path resolution + injection).\n\n    Raises\n      SystemExit on YAML parse errors (with chained context),\n      FileNotFoundError if the recipe file itself is missing.\n    \"\"\"\n    from notapkgtool.cli import print_debug, print_verbose\n\n    recipe_path = recipe_path.resolve()\n    recipe_dir = recipe_path.parent\n\n    print_verbose(\"CONFIG\", f\"Loading recipe: {recipe_path}\")\n\n    # 1) Read recipe\n    recipe_obj = _load_yaml_file(recipe_path)\n    if not isinstance(recipe_obj, dict):\n        print(f\"Error: top-level YAML must be a mapping (dict): {recipe_path}\")\n        raise SystemExit(1)\n\n    # 2) Find defaults root\n    defaults_root = _find_defaults_root(recipe_dir)\n    if defaults_root and verbose:\n        print_verbose(\"CONFIG\", f\"Found defaults root: {defaults_root}\")\n\n    merged: dict[str, Any] = {}\n    layers_merged = 0\n\n    org_defaults_path: Path | None = None\n    vendor_name: str | None = vendor\n\n    if defaults_root:\n        # 3) Load org defaults\n        org_defaults_path = defaults_root / \"org.yaml\"\n        if org_defaults_path.exists():\n            print_verbose(\n                \"CONFIG\",\n                f\"Loading: {org_defaults_path.relative_to(defaults_root.parent)}\",\n            )\n            org_defaults = _load_yaml_file(org_defaults_path)\n            if isinstance(org_defaults, dict):\n                if debug:\n                    print_debug(\"CONFIG\", \"--- Content from org.yaml ---\")\n                    _print_yaml_content(org_defaults, debug)\n                merged = _deep_merge_dicts(merged, org_defaults)\n                layers_merged += 1\n\n        # 4) Determine vendor\n        if vendor_name is None:\n            vendor_name = _detect_vendor(recipe_path, recipe_obj)\n\n        if vendor_name and verbose:\n            print_verbose(\"CONFIG\", f\"Detected vendor: {vendor_name}\")\n\n        # 5) Load vendor defaults if present\n        if vendor_name:\n            candidate = defaults_root / \"vendors\" / f\"{vendor_name}.yaml\"\n            if candidate.exists():\n                print_verbose(\n                    \"CONFIG\", f\"Loading: {candidate.relative_to(defaults_root.parent)}\"\n                )\n                vendor_defaults = _load_yaml_file(candidate)\n                if isinstance(vendor_defaults, dict):\n                    if debug:\n                        print_debug(\n                            \"CONFIG\", f\"--- Content from {vendor_name}.yaml ---\"\n                        )\n                        _print_yaml_content(vendor_defaults, debug)\n                    merged = _deep_merge_dicts(merged, vendor_defaults)\n                    layers_merged += 1\n\n    # Show recipe content if verbose\n    if verbose:\n        print_verbose(\"CONFIG\", f\"Loading: {recipe_path.name}\")\n    if debug:\n        print_debug(\"CONFIG\", f\"--- Content from {recipe_path.name} ---\")\n        _print_yaml_content(recipe_obj, debug)\n\n    # 6) Merge recipe on top\n    merged = _deep_merge_dicts(merged, recipe_obj)\n    layers_merged += 1\n\n    if verbose:\n        print_verbose(\"CONFIG\", f\"Deep merging {layers_merged} layer(s)\")\n        # Show final config structure\n        top_level_keys = list(merged.keys())\n        print_verbose(\n            \"CONFIG\",\n            f\"Final config has {len(top_level_keys)} top-level keys: {', '.join(top_level_keys)}\",\n        )\n    # Show the complete merged configuration in debug mode\n    if debug:\n        print_debug(\"CONFIG\", \"--- Final Merged Configuration ---\")\n        _print_yaml_content(merged, debug)\n\n    # 7) Resolve relative paths (branding paths relative to defaults_root)\n    _resolve_known_paths(merged, recipe_dir, defaults_root)\n\n    # 8) Inject dynamic values (e.g., AppScriptDate)\n    _inject_dynamic_values(merged)\n\n    # Optionally attach context for debugging (commented out by default)\n    # merged[\"_load_context\"] = LoadContext(\n    #     recipe_path=recipe_path,\n    #     defaults_root=defaults_root,\n    #     vendor_name=vendor_name,\n    #     org_defaults_path=org_defaults_path,\n    #     vendor_defaults_path=vendor_defaults_path,\n    # ).__dict__\n\n    return merged\n</code></pre>"},{"location":"api/core/","title":"Core Module","text":"<p>The core module provides high-level orchestration functions that coordinate the complete workflow for recipe validation, package building, and deployment.</p> <p>The orchestration uses a two-path architecture that automatically optimizes based on discovery strategy capabilities:</p> <ul> <li> <p>Version-First Path: For strategies with <code>get_version_info()</code> method (url_regex, github_release, http_json), discovers version first, compares to cache, and skips downloads entirely when unchanged.</p> </li> <li> <p>File-First Path: For strategies with only <code>discover_version()</code> method (http_static), uses HTTP ETag conditional requests to minimize bandwidth.</p> </li> </ul>"},{"location":"api/core/#notapkgtool.core","title":"<code>notapkgtool.core</code>","text":"<p>Core orchestration for NAPT.</p> <p>This module provides high-level orchestration functions that coordinate the complete workflow for recipe validation, package building, and deployment.</p> <p>The orchestration uses a two-path architecture:</p> <p>VERSION-FIRST PATH (url_regex, github_release, http_json):   1. Load and merge configuration (org defaults + vendor + recipe)   2. Call strategy.get_version_info() to discover version (no download)   3. Compare discovered version to cached known_version   4. If match and file exists -&gt; skip download entirely (fast path!)   5. If changed or missing -&gt; download installer   6. Update state and return results</p> <p>FILE-FIRST PATH (http_static):   1. Load and merge configuration (org defaults + vendor + recipe)   2. Call strategy.discover_version() with cached ETag   3. Server returns HTTP 304 (not modified) -&gt; use cached file   4. Server returns HTTP 200 (modified) -&gt; download new version   5. Extract version from downloaded file   6. Update state and return results</p>"},{"location":"api/core/#notapkgtool.core--functions","title":"Functions","text":"<p>discover_recipe : function     Discover the latest version and download installer.     This is the entry point for the 'napt discover' command.     Automatically uses version-first optimization when available.</p> function <p>Derive expected file path from URL for cache lookups.</p>"},{"location":"api/core/#notapkgtool.core--see-also","title":"See Also","text":"<p>validate_recipe : notapkgtool.validation     Validate recipe syntax without downloads. build_package : notapkgtool.build     Build PSADT package from recipe and installer. create_intunewin : notapkgtool.build     Create .intunewin package for Intune deployment.</p> Future orchestration functions <p>upload_package : Upload a built package to Microsoft Intune sync_recipe : Full workflow (discover -&gt; build -&gt; package -&gt; upload)</p>"},{"location":"api/core/#notapkgtool.core--design-principles","title":"Design Principles","text":"<ul> <li>Each function has a single, clear responsibility</li> <li>Functions return structured data (dicts) for easy testing and extension</li> <li>Error handling uses exceptions; CLI layer formats for user display</li> <li>Discovery strategies are dynamically loaded via registry pattern</li> <li>Configuration is immutable once loaded</li> <li>Version-first strategies preferred for performance (skip downloads when unchanged)</li> </ul>"},{"location":"api/core/#notapkgtool.core--example","title":"Example","text":"<p>Programmatic usage:</p> <pre><code>from pathlib import Path\nfrom notapkgtool.core import discover_recipe\n\nresult = discover_recipe(\n    recipe_path=Path(\"recipes/Google/chrome.yaml\"),\n    output_dir=Path(\"./downloads\"),\n)\n\nprint(f\"App: {result['app_name']}\")\nprint(f\"Version: {result['version']}\")\nprint(f\"SHA-256: {result['sha256']}\")\n\n# Version-first strategies: may have skipped download if unchanged!\n</code></pre>"},{"location":"api/core/#notapkgtool.core.derive_file_path_from_url","title":"<code>derive_file_path_from_url(url, output_dir)</code>","text":"<p>Derive file path from URL using same logic as download_file.</p> <p>This function ensures version-first strategies can locate cached files without downloading by following the same naming convention as the download module.</p>"},{"location":"api/core/#notapkgtool.core.derive_file_path_from_url--parameters","title":"Parameters","text":"<p>url : str     Download URL. output_dir : Path     Directory where file would be downloaded.</p>"},{"location":"api/core/#notapkgtool.core.derive_file_path_from_url--returns","title":"Returns","text":"<p>Path     Expected path to the file.</p>"},{"location":"api/core/#notapkgtool.core.derive_file_path_from_url--examples","title":"Examples","text":"<p>derive_file_path_from_url(\"https://example.com/app.msi\", Path(\"./downloads\")) Path('./downloads/app.msi')</p> Source code in <code>notapkgtool/core.py</code> <pre><code>def derive_file_path_from_url(url: str, output_dir: Path) -&gt; Path:\n    \"\"\"\n    Derive file path from URL using same logic as download_file.\n\n    This function ensures version-first strategies can locate cached files\n    without downloading by following the same naming convention as the\n    download module.\n\n    Parameters\n    ----------\n    url : str\n        Download URL.\n    output_dir : Path\n        Directory where file would be downloaded.\n\n    Returns\n    -------\n    Path\n        Expected path to the file.\n\n    Examples\n    --------\n    &gt;&gt;&gt; derive_file_path_from_url(\"https://example.com/app.msi\", Path(\"./downloads\"))\n    Path('./downloads/app.msi')\n    \"\"\"\n    from urllib.parse import urlparse\n\n    filename = Path(urlparse(url).path).name\n    return output_dir / filename\n</code></pre>"},{"location":"api/core/#notapkgtool.core.discover_recipe","title":"<code>discover_recipe(recipe_path, output_dir, state_file=Path('state/versions.json'), stateless=False, verbose=False, debug=False)</code>","text":"<p>Discover the latest version by loading config and downloading installer.</p> <p>This is the main entry point for the 'napt discover' command. It orchestrates the entire discovery workflow using a two-path architecture optimized for version-first strategies.</p> <p>The function uses duck typing to detect strategy capabilities:</p> <p>VERSION-FIRST PATH (if strategy has get_version_info method):   1. Load effective configuration (org + vendor + recipe merged)   2. Call strategy.get_version_info() to discover version (no download)   3. Compare discovered version to cached known_version   4. If match and file exists -&gt; skip download entirely (fast path!)   5. If changed or missing -&gt; download installer via download_file()   6. Update state and return results</p> <p>FILE-FIRST PATH (if strategy has only discover_version method):   1. Load effective configuration (org + vendor + recipe merged)   2. Call strategy.discover_version() with cached ETag   3. Strategy handles conditional request (HTTP 304 vs 200)   4. Extract version from downloaded file   5. Update state and return results</p>"},{"location":"api/core/#notapkgtool.core.discover_recipe--parameters","title":"Parameters","text":"<p>recipe_path : Path     Path to the recipe YAML file. Must exist and be readable.     The path is resolved to absolute form. output_dir : Path     Directory to download the installer to. Created if it doesn't exist.     The downloaded file will be named based on Content-Disposition header     or URL path. state_file : Path, optional     Path to state file for version tracking and ETag caching.     Default is \"state/versions.json\". Set to None to disable. stateless : bool, optional     If True, disable state tracking (no caching, always download).     Default is False.</p>"},{"location":"api/core/#notapkgtool.core.discover_recipe--returns","title":"Returns","text":"<p>dict[str, Any]     Results dictionary containing:     - app_name : str - Application display name     - app_id : str - Unique identifier for the app     - strategy : str - Discovery strategy used (e.g., \"http_static\")     - version : str - Extracted version string     - version_source : str - How version was determined (e.g., \"msi_product_version_from_file\")     - file_path : Path - Absolute path to downloaded installer     - sha256 : str - SHA-256 hash of the downloaded file (hex)     - status : str - Always \"success\" if no exception raised</p>"},{"location":"api/core/#notapkgtool.core.discover_recipe--raises","title":"Raises","text":"<p>SystemExit     On YAML parse errors or missing recipe file (handled by config loader). ValueError     On missing or invalid configuration fields:     - No apps defined in recipe     - Missing 'source.strategy' field     - Unknown discovery strategy name RuntimeError     On download failures or version extraction errors. FileNotFoundError     If recipe file doesn't exist (before config loading).</p>"},{"location":"api/core/#notapkgtool.core.discover_recipe--examples","title":"Examples","text":"<p>Basic version discovery:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; result = discover_recipe(\n...     Path(\"recipes/Google/chrome.yaml\"),\n...     Path(\"./downloads\")\n... )\n&gt;&gt;&gt; print(result['version'])\n141.0.7390.123\n</code></pre> <p>Handling errors:</p> <pre><code>&gt;&gt;&gt; try:\n...     result = discover_recipe(Path(\"invalid.yaml\"), Path(\".\"))\n... except ValueError as e:\n...     print(f\"Config error: {e}\")\n... except RuntimeError as e:\n...     print(f\"Download error: {e}\")\n</code></pre>"},{"location":"api/core/#notapkgtool.core.discover_recipe--notes","title":"Notes","text":"<ul> <li>Only the first app in a recipe is currently processed</li> <li>The discovery strategy must be registered before calling this function</li> <li>Version-first strategies (url_regex, github_release, http_json) can skip   downloads entirely when version unchanged (fast path optimization)</li> <li>File-first strategy (http_static) uses ETag conditional requests</li> <li>Downloaded files are written atomically (.part then renamed)</li> <li>Progress output goes to stdout via the download module</li> <li>Strategy type detected via duck typing (hasattr for get_version_info)</li> </ul> Source code in <code>notapkgtool/core.py</code> <pre><code>def discover_recipe(\n    recipe_path: Path,\n    output_dir: Path,\n    state_file: Path | None = Path(\"state/versions.json\"),\n    stateless: bool = False,\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Discover the latest version by loading config and downloading installer.\n\n    This is the main entry point for the 'napt discover' command. It orchestrates\n    the entire discovery workflow using a two-path architecture optimized for\n    version-first strategies.\n\n    The function uses duck typing to detect strategy capabilities:\n\n    VERSION-FIRST PATH (if strategy has get_version_info method):\n      1. Load effective configuration (org + vendor + recipe merged)\n      2. Call strategy.get_version_info() to discover version (no download)\n      3. Compare discovered version to cached known_version\n      4. If match and file exists -&gt; skip download entirely (fast path!)\n      5. If changed or missing -&gt; download installer via download_file()\n      6. Update state and return results\n\n    FILE-FIRST PATH (if strategy has only discover_version method):\n      1. Load effective configuration (org + vendor + recipe merged)\n      2. Call strategy.discover_version() with cached ETag\n      3. Strategy handles conditional request (HTTP 304 vs 200)\n      4. Extract version from downloaded file\n      5. Update state and return results\n\n    Parameters\n    ----------\n    recipe_path : Path\n        Path to the recipe YAML file. Must exist and be readable.\n        The path is resolved to absolute form.\n    output_dir : Path\n        Directory to download the installer to. Created if it doesn't exist.\n        The downloaded file will be named based on Content-Disposition header\n        or URL path.\n    state_file : Path, optional\n        Path to state file for version tracking and ETag caching.\n        Default is \"state/versions.json\". Set to None to disable.\n    stateless : bool, optional\n        If True, disable state tracking (no caching, always download).\n        Default is False.\n\n    Returns\n    -------\n    dict[str, Any]\n        Results dictionary containing:\n        - app_name : str - Application display name\n        - app_id : str - Unique identifier for the app\n        - strategy : str - Discovery strategy used (e.g., \"http_static\")\n        - version : str - Extracted version string\n        - version_source : str - How version was determined (e.g., \"msi_product_version_from_file\")\n        - file_path : Path - Absolute path to downloaded installer\n        - sha256 : str - SHA-256 hash of the downloaded file (hex)\n        - status : str - Always \"success\" if no exception raised\n\n    Raises\n    ------\n    SystemExit\n        On YAML parse errors or missing recipe file (handled by config loader).\n    ValueError\n        On missing or invalid configuration fields:\n        - No apps defined in recipe\n        - Missing 'source.strategy' field\n        - Unknown discovery strategy name\n    RuntimeError\n        On download failures or version extraction errors.\n    FileNotFoundError\n        If recipe file doesn't exist (before config loading).\n\n    Examples\n    --------\n    Basic version discovery:\n\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; result = discover_recipe(\n        ...     Path(\"recipes/Google/chrome.yaml\"),\n        ...     Path(\"./downloads\")\n        ... )\n        &gt;&gt;&gt; print(result['version'])\n        141.0.7390.123\n\n    Handling errors:\n\n        &gt;&gt;&gt; try:\n        ...     result = discover_recipe(Path(\"invalid.yaml\"), Path(\".\"))\n        ... except ValueError as e:\n        ...     print(f\"Config error: {e}\")\n        ... except RuntimeError as e:\n        ...     print(f\"Download error: {e}\")\n\n    Notes\n    -----\n    - Only the first app in a recipe is currently processed\n    - The discovery strategy must be registered before calling this function\n    - Version-first strategies (url_regex, github_release, http_json) can skip\n      downloads entirely when version unchanged (fast path optimization)\n    - File-first strategy (http_static) uses ETag conditional requests\n    - Downloaded files are written atomically (.part then renamed)\n    - Progress output goes to stdout via the download module\n    - Strategy type detected via duck typing (hasattr for get_version_info)\n    \"\"\"\n    from notapkgtool.cli import print_step, print_verbose\n\n    # Load state file unless running in stateless mode\n    state = None\n    if not stateless and state_file:\n        try:\n            state = load_state(state_file)\n            print_verbose(\"STATE\", f\"Loaded state from {state_file}\")\n        except FileNotFoundError:\n            print_verbose(\"STATE\", f\"State file not found, will create: {state_file}\")\n            state = {\n                \"metadata\": {\"napt_version\": \"0.1.0\", \"schema_version\": \"1\"},\n                \"apps\": {},\n            }\n        except Exception as err:\n            print_verbose(\"STATE\", f\"Warning: Failed to load state: {err}\")\n            print_verbose(\"STATE\", \"Continuing without state tracking\")\n            state = None\n\n    # 1. Load and merge configuration\n    print_step(1, 4, \"Loading configuration...\")\n    config = load_effective_config(recipe_path, verbose=verbose, debug=debug)\n\n    # 2. Extract the first app (for now we only process one app per recipe)\n    print_step(2, 4, \"Discovering version...\")\n    apps = config.get(\"apps\", [])\n    if not apps:\n        raise ValueError(f\"No apps defined in recipe: {recipe_path}\")\n\n    app = apps[0]\n    app_name = app.get(\"name\", \"Unknown\")\n    app_id = app.get(\"id\", \"unknown-id\")\n\n    # 3. Get the discovery strategy name\n    source = app.get(\"source\", {})\n    strategy_name = source.get(\"strategy\")\n    if not strategy_name:\n        raise ValueError(f\"No 'source.strategy' defined for app: {app_name}\")\n\n    # 4. Get the strategy implementation\n    # Import strategies to ensure they're registered\n    import notapkgtool.discovery.github_release  # noqa: F401\n    import notapkgtool.discovery.http_json  # noqa: F401\n    import notapkgtool.discovery.http_static  # noqa: F401\n    import notapkgtool.discovery.url_regex  # noqa: F401\n\n    strategy = get_strategy(strategy_name)\n\n    # Get cache for this recipe from state\n    cache = None\n    if state and app_id:\n        cache = state.get(\"apps\", {}).get(app_id)\n        if cache:\n            print_verbose(\"STATE\", f\"Using cache for {app_id}\")\n            if cache.get(\"known_version\"):\n                print_verbose(\n                    \"STATE\", f\"  Cached version: {cache.get('known_version')}\"\n                )\n            if cache.get(\"etag\"):\n                print_verbose(\"STATE\", f\"  Cached ETag: {cache.get('etag')}\")\n\n    # 5. Run discovery: version-first or file-first path\n    print_step(3, 4, \"Discovering version...\")\n\n    # Check if strategy supports version-first (has get_version_info method)\n    download_url = None  # Track actual download URL for state file\n    if hasattr(strategy, \"get_version_info\"):\n        # VERSION-FIRST PATH (url_regex, github_release, http_json)\n        # Get version without downloading\n        version_info = strategy.get_version_info(app, verbose=verbose, debug=debug)\n        download_url = version_info.download_url  # Save for state file\n\n        print_verbose(\"DISCOVERY\", f\"Version discovered: {version_info.version}\")\n\n        # Check if we can use cached file (version match + file exists)\n        if cache and cache.get(\"known_version\") == version_info.version:\n            # Derive file path from URL using same logic as download_file\n            file_path = derive_file_path_from_url(version_info.download_url, output_dir)\n\n            if file_path.exists():\n                # Fast path: version unchanged, file exists, skip download!\n                print_verbose(\n                    \"CACHE\",\n                    f\"Version {version_info.version} unchanged, using cached file\",\n                )\n                print_step(4, 4, \"Using cached file...\")\n                sha256 = cache.get(\"sha256\")\n                discovered_version = DiscoveredVersion(\n                    version_info.version, version_info.source\n                )\n                headers = {}  # No download occurred, no headers\n            else:\n                # File was deleted, re-download\n                print_verbose(\n                    \"WARNING\",\n                    f\"Cached file {file_path} not found, re-downloading\",\n                )\n                print_step(4, 4, \"Downloading installer...\")\n                file_path, sha256, headers = download_file(\n                    version_info.download_url,\n                    output_dir,\n                    verbose=verbose,\n                    debug=debug,\n                )\n                discovered_version = DiscoveredVersion(\n                    version_info.version, version_info.source\n                )\n        else:\n            # Version changed or no cache, download new version\n            if cache:\n                print_verbose(\n                    \"DISCOVERY\",\n                    f\"Version changed: {cache.get('known_version')} \u2192 {version_info.version}\",\n                )\n            print_step(4, 4, \"Downloading installer...\")\n            file_path, sha256, headers = download_file(\n                version_info.download_url,\n                output_dir,\n                verbose=verbose,\n                debug=debug,\n            )\n            discovered_version = DiscoveredVersion(\n                version_info.version, version_info.source\n            )\n    else:\n        # FILE-FIRST PATH (http_static only)\n        # Must download to extract version\n        print_step(4, 4, \"Downloading installer...\")\n        discovered_version, file_path, sha256, headers = strategy.discover_version(\n            app, output_dir, cache=cache, verbose=verbose, debug=debug\n        )\n        download_url = str(app.get(\"source\", {}).get(\"url\", \"\"))  # Use source.url\n\n    # Update state with discovered information\n    if state and app_id and state_file:\n        from datetime import UTC, datetime\n\n        if \"apps\" not in state:\n            state[\"apps\"] = {}\n\n        # Extract ETag and Last-Modified from headers for next run\n        etag = headers.get(\"ETag\")\n        last_modified = headers.get(\"Last-Modified\")\n\n        if etag:\n            print_verbose(\"STATE\", f\"Saving ETag for next run: {etag}\")\n        if last_modified:\n            print_verbose(\n                \"STATE\", f\"Saving Last-Modified for next run: {last_modified}\"\n            )\n\n        # Build cache entry with new schema v2\n        cache_entry = {\n            \"url\": download_url\n            or \"\",  # Actual download URL (from version_info or source.url)\n            \"etag\": etag if etag else None,  # Only useful for http_static\n            \"last_modified\": (\n                last_modified if last_modified else None\n            ),  # Only useful for http_static\n            \"sha256\": sha256,\n        }\n\n        # Optional fields\n        if discovered_version.version:\n            cache_entry[\"known_version\"] = discovered_version.version\n        if strategy_name:\n            cache_entry[\"strategy\"] = strategy_name\n\n        state[\"apps\"][app_id] = cache_entry\n\n        state[\"metadata\"] = {\n            \"napt_version\": \"0.1.0\",\n            \"last_updated\": datetime.now(UTC).isoformat(),\n            \"schema_version\": \"2\",\n        }\n\n        try:\n            save_state(state, state_file)\n            print_verbose(\"STATE\", f\"Updated state file: {state_file}\")\n        except Exception as err:\n            print_verbose(\"STATE\", f\"Warning: Failed to save state: {err}\")\n\n    # 6. Return results\n    return {\n        \"app_name\": app_name,\n        \"app_id\": app_id,\n        \"strategy\": strategy_name,\n        \"version\": discovered_version.version,\n        \"version_source\": discovered_version.source,\n        \"file_path\": file_path,\n        \"sha256\": sha256,\n        \"status\": \"success\",\n    }\n</code></pre>"},{"location":"api/discovery/","title":"Discovery Module","text":"<p>The discovery module implements the strategy pattern for obtaining application installers and extracting version information.</p> <p>NAPT supports two types of discovery strategies:</p> <ul> <li> <p>Version-First Strategies (url_regex, github_release, http_json): Discover version without downloading, enabling instant update checks and the ability to skip downloads entirely when versions are unchanged.</p> </li> <li> <p>File-First Strategy (http_static): Must download file to extract version, uses HTTP ETag conditional requests for optimization.</p> </li> </ul>"},{"location":"api/discovery/#base-protocol","title":"Base Protocol","text":""},{"location":"api/discovery/#notapkgtool.discovery.base","title":"<code>notapkgtool.discovery.base</code>","text":"<p>Discovery strategy base protocol and registry for NAPT.</p> This module defines the foundational components for the discovery system <ul> <li>DiscoveryStrategy protocol: Interface that all strategies must implement</li> <li>Strategy registry: Global dict mapping strategy names to implementations</li> <li>Registration and lookup functions: register_strategy() and get_strategy()</li> </ul> <p>The discovery system uses a strategy pattern to support multiple ways of obtaining application installers and their versions:   - http_static: Direct download from a static URL   - url_regex: Parse version from URL patterns using regex   - github_release: Fetch from GitHub releases API   - http_json: Query JSON API endpoints with JSONPath</p>"},{"location":"api/discovery/#notapkgtool.discovery.base--design-philosophy","title":"Design Philosophy","text":"<ul> <li>Strategies are Protocol classes (structural subtyping, not inheritance)</li> <li>Registration happens at module import time (strategies self-register)</li> <li>Registry is a simple dict (no complex dependency injection needed)</li> <li>Each strategy is stateless and can be instantiated on-demand</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.base--protocol-benefits","title":"Protocol Benefits","text":"<p>Using typing.Protocol instead of ABC allows:   - Duck typing: Classes don't need explicit inheritance   - Better IDE support: Type checkers verify interface compliance   - Flexibility: Third-party code can add strategies without touching base</p>"},{"location":"api/discovery/#notapkgtool.discovery.base--example","title":"Example","text":"<p>Implementing a custom strategy:</p> <pre><code>from notapkgtool.discovery.base import register_strategy, DiscoveryStrategy\nfrom pathlib import Path\nfrom typing import Any\nfrom notapkgtool.versioning.keys import DiscoveredVersion\n\nclass MyCustomStrategy:\n    def discover_version(\n        self, app_config: dict[str, Any], output_dir: Path\n    ) -&gt; tuple[DiscoveredVersion, Path, str]:\n        # Implement your discovery logic here\n        ...\n\n# Register it (typically at module import)\nregister_strategy(\"my_custom\", MyCustomStrategy)\n\n# Now it can be used in recipes:\n# source:\n#   strategy: my_custom\n#   ...\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy","title":"<code>DiscoveryStrategy</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for version discovery strategies.</p> <p>Each strategy must implement discover_version() which downloads and extracts version information based on the app config.</p> <p>Strategies may optionally implement validate_config() to provide strategy-specific configuration validation without network calls.</p> Source code in <code>notapkgtool/discovery/base.py</code> <pre><code>class DiscoveryStrategy(Protocol):\n    \"\"\"\n    Protocol for version discovery strategies.\n\n    Each strategy must implement discover_version() which downloads\n    and extracts version information based on the app config.\n\n    Strategies may optionally implement validate_config() to provide\n    strategy-specific configuration validation without network calls.\n    \"\"\"\n\n    def discover_version(\n        self, app_config: dict[str, Any], output_dir: Path\n    ) -&gt; tuple[DiscoveredVersion, Path, str, dict]:\n        \"\"\"\n        Discover and download an application version.\n\n        Parameters\n        ----------\n        app_config : dict\n            The app configuration from the recipe (`config[\"apps\"][0]`).\n        output_dir : Path\n            Directory to download the installer to.\n\n        Returns\n        -------\n        tuple[DiscoveredVersion, Path, str, dict]\n            - DiscoveredVersion: version info\n            - Path: path to downloaded file\n            - str: SHA-256 hash of the file\n            - dict: HTTP response headers (for ETag/Last-Modified caching)\n\n        Raises\n        ------\n        ValueError, RuntimeError\n            On discovery or download failures.\n        \"\"\"\n        ...\n\n    def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n        \"\"\"\n        Validate strategy-specific configuration (optional).\n\n        This method validates the app configuration for strategy-specific\n        requirements without making network calls or downloading files.\n        Useful for quick feedback during recipe development.\n\n        Parameters\n        ----------\n        app_config : dict\n            The app configuration from the recipe (`config[\"apps\"][0]`).\n\n        Returns\n        -------\n        list[str]\n            List of error messages. Empty list if configuration is valid.\n            Each error should be a human-readable description of the issue.\n\n        Examples\n        --------\n        Check required fields:\n\n            &gt;&gt;&gt; def validate_config(self, app_config):\n            ...     errors = []\n            ...     source = app_config.get(\"source\", {})\n            ...     if \"url\" not in source:\n            ...         errors.append(\"Missing required field: source.url\")\n            ...     return errors\n\n        Notes\n        -----\n        - This method is optional; strategies without it will skip validation\n        - Should NOT make network calls or download files\n        - Should check field presence, types, and format only\n        - Used by 'napt validate' command for fast recipe checking\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.discover_version","title":"<code>discover_version(app_config, output_dir)</code>","text":"<p>Discover and download an application version.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.discover_version--parameters","title":"Parameters","text":"<p>app_config : dict     The app configuration from the recipe (<code>config[\"apps\"][0]</code>). output_dir : Path     Directory to download the installer to.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.discover_version--returns","title":"Returns","text":"<p>tuple[DiscoveredVersion, Path, str, dict]     - DiscoveredVersion: version info     - Path: path to downloaded file     - str: SHA-256 hash of the file     - dict: HTTP response headers (for ETag/Last-Modified caching)</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.discover_version--raises","title":"Raises","text":"<p>ValueError, RuntimeError     On discovery or download failures.</p> Source code in <code>notapkgtool/discovery/base.py</code> <pre><code>def discover_version(\n    self, app_config: dict[str, Any], output_dir: Path\n) -&gt; tuple[DiscoveredVersion, Path, str, dict]:\n    \"\"\"\n    Discover and download an application version.\n\n    Parameters\n    ----------\n    app_config : dict\n        The app configuration from the recipe (`config[\"apps\"][0]`).\n    output_dir : Path\n        Directory to download the installer to.\n\n    Returns\n    -------\n    tuple[DiscoveredVersion, Path, str, dict]\n        - DiscoveredVersion: version info\n        - Path: path to downloaded file\n        - str: SHA-256 hash of the file\n        - dict: HTTP response headers (for ETag/Last-Modified caching)\n\n    Raises\n    ------\n    ValueError, RuntimeError\n        On discovery or download failures.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.validate_config","title":"<code>validate_config(app_config)</code>","text":"<p>Validate strategy-specific configuration (optional).</p> <p>This method validates the app configuration for strategy-specific requirements without making network calls or downloading files. Useful for quick feedback during recipe development.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.validate_config--parameters","title":"Parameters","text":"<p>app_config : dict     The app configuration from the recipe (<code>config[\"apps\"][0]</code>).</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.validate_config--returns","title":"Returns","text":"<p>list[str]     List of error messages. Empty list if configuration is valid.     Each error should be a human-readable description of the issue.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.validate_config--examples","title":"Examples","text":"<p>Check required fields:</p> <pre><code>&gt;&gt;&gt; def validate_config(self, app_config):\n...     errors = []\n...     source = app_config.get(\"source\", {})\n...     if \"url\" not in source:\n...         errors.append(\"Missing required field: source.url\")\n...     return errors\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.DiscoveryStrategy.validate_config--notes","title":"Notes","text":"<ul> <li>This method is optional; strategies without it will skip validation</li> <li>Should NOT make network calls or download files</li> <li>Should check field presence, types, and format only</li> <li>Used by 'napt validate' command for fast recipe checking</li> </ul> Source code in <code>notapkgtool/discovery/base.py</code> <pre><code>def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n    \"\"\"\n    Validate strategy-specific configuration (optional).\n\n    This method validates the app configuration for strategy-specific\n    requirements without making network calls or downloading files.\n    Useful for quick feedback during recipe development.\n\n    Parameters\n    ----------\n    app_config : dict\n        The app configuration from the recipe (`config[\"apps\"][0]`).\n\n    Returns\n    -------\n    list[str]\n        List of error messages. Empty list if configuration is valid.\n        Each error should be a human-readable description of the issue.\n\n    Examples\n    --------\n    Check required fields:\n\n        &gt;&gt;&gt; def validate_config(self, app_config):\n        ...     errors = []\n        ...     source = app_config.get(\"source\", {})\n        ...     if \"url\" not in source:\n        ...         errors.append(\"Missing required field: source.url\")\n        ...     return errors\n\n    Notes\n    -----\n    - This method is optional; strategies without it will skip validation\n    - Should NOT make network calls or download files\n    - Should check field presence, types, and format only\n    - Used by 'napt validate' command for fast recipe checking\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.register_strategy","title":"<code>register_strategy(name, strategy_class)</code>","text":"<p>Register a discovery strategy by name in the global registry.</p> <p>This function should be called when a strategy module is imported, typically at module level. Registering the same name twice will overwrite the previous registration (allows monkey-patching for tests).</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.register_strategy--parameters","title":"Parameters","text":"<p>name : str     Strategy name (e.g., \"http_static\"). This is the value used in     recipe YAML files under source.strategy. Names should be lowercase     with underscores for readability. strategy_class : type[DiscoveryStrategy]     The strategy class to register. Must implement the DiscoveryStrategy     protocol (have a discover_version method with the correct signature).</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.register_strategy--examples","title":"Examples","text":"<p>Register at module import time:</p> <pre><code># In discovery/my_strategy.py\nfrom .base import register_strategy\n\nclass MyStrategy:\n    def discover_version(self, app_config, output_dir):\n        ...\n\nregister_strategy(\"my_strategy\", MyStrategy)\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.register_strategy--notes","title":"Notes","text":"<ul> <li>No validation is performed at registration time</li> <li>Type checkers will verify protocol compliance at static analysis time</li> <li>Runtime errors occur at strategy instantiation or invocation</li> </ul> Source code in <code>notapkgtool/discovery/base.py</code> <pre><code>def register_strategy(name: str, strategy_class: type[DiscoveryStrategy]) -&gt; None:\n    \"\"\"\n    Register a discovery strategy by name in the global registry.\n\n    This function should be called when a strategy module is imported,\n    typically at module level. Registering the same name twice will\n    overwrite the previous registration (allows monkey-patching for tests).\n\n    Parameters\n    ----------\n    name : str\n        Strategy name (e.g., \"http_static\"). This is the value used in\n        recipe YAML files under source.strategy. Names should be lowercase\n        with underscores for readability.\n    strategy_class : type[DiscoveryStrategy]\n        The strategy class to register. Must implement the DiscoveryStrategy\n        protocol (have a discover_version method with the correct signature).\n\n    Examples\n    --------\n    Register at module import time:\n\n        # In discovery/my_strategy.py\n        from .base import register_strategy\n\n        class MyStrategy:\n            def discover_version(self, app_config, output_dir):\n                ...\n\n        register_strategy(\"my_strategy\", MyStrategy)\n\n    Notes\n    -----\n    - No validation is performed at registration time\n    - Type checkers will verify protocol compliance at static analysis time\n    - Runtime errors occur at strategy instantiation or invocation\n    \"\"\"\n    _STRATEGY_REGISTRY[name] = strategy_class\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.get_strategy","title":"<code>get_strategy(name)</code>","text":"<p>Get a discovery strategy instance by name from the global registry.</p> <p>The strategy is instantiated on-demand (strategies are stateless, so a new instance is created for each call). The strategy module must have been imported first for registration to occur.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.get_strategy--parameters","title":"Parameters","text":"<p>name : str     Strategy name (e.g., \"http_static\"). Must exactly match a name     registered via register_strategy(). Case-sensitive.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.get_strategy--returns","title":"Returns","text":"<p>DiscoveryStrategy     A new instance of the requested strategy, ready to use.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.get_strategy--raises","title":"Raises","text":"<p>ValueError     If the strategy name is not registered. The error message includes     a list of available strategies for troubleshooting.</p>"},{"location":"api/discovery/#notapkgtool.discovery.base.get_strategy--examples","title":"Examples","text":"<p>Get and use a strategy:</p> <pre><code>&gt;&gt;&gt; from notapkgtool.discovery import get_strategy\n&gt;&gt;&gt; strategy = get_strategy(\"http_static\")\n&gt;&gt;&gt; # Use strategy.discover_version(...)\n</code></pre> <p>Handle unknown strategy:</p> <pre><code>&gt;&gt;&gt; try:\n...     strategy = get_strategy(\"nonexistent\")\n... except ValueError as e:\n...     print(f\"Strategy not found: {e}\")\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.base.get_strategy--notes","title":"Notes","text":"<ul> <li>Strategies must be registered before they can be retrieved</li> <li>The http_static strategy is auto-registered when imported</li> <li>New strategies can be added by creating a module and registering</li> </ul> Source code in <code>notapkgtool/discovery/base.py</code> <pre><code>def get_strategy(name: str) -&gt; DiscoveryStrategy:\n    \"\"\"\n    Get a discovery strategy instance by name from the global registry.\n\n    The strategy is instantiated on-demand (strategies are stateless, so\n    a new instance is created for each call). The strategy module must\n    have been imported first for registration to occur.\n\n    Parameters\n    ----------\n    name : str\n        Strategy name (e.g., \"http_static\"). Must exactly match a name\n        registered via register_strategy(). Case-sensitive.\n\n    Returns\n    -------\n    DiscoveryStrategy\n        A new instance of the requested strategy, ready to use.\n\n    Raises\n    ------\n    ValueError\n        If the strategy name is not registered. The error message includes\n        a list of available strategies for troubleshooting.\n\n    Examples\n    --------\n    Get and use a strategy:\n\n        &gt;&gt;&gt; from notapkgtool.discovery import get_strategy\n        &gt;&gt;&gt; strategy = get_strategy(\"http_static\")\n        &gt;&gt;&gt; # Use strategy.discover_version(...)\n\n    Handle unknown strategy:\n\n        &gt;&gt;&gt; try:\n        ...     strategy = get_strategy(\"nonexistent\")\n        ... except ValueError as e:\n        ...     print(f\"Strategy not found: {e}\")\n\n    Notes\n    -----\n    - Strategies must be registered before they can be retrieved\n    - The http_static strategy is auto-registered when imported\n    - New strategies can be added by creating a module and registering\n    \"\"\"\n    if name not in _STRATEGY_REGISTRY:\n        available = \", \".join(_STRATEGY_REGISTRY.keys())\n        raise ValueError(\n            f\"Unknown discovery strategy: {name!r}. Available: {available or '(none)'}\"\n        )\n    return _STRATEGY_REGISTRY[name]()\n</code></pre>"},{"location":"api/discovery/#http-static-strategy","title":"HTTP Static Strategy","text":""},{"location":"api/discovery/#notapkgtool.discovery.http_static","title":"<code>notapkgtool.discovery.http_static</code>","text":"<p>HTTP static URL discovery strategy for NAPT.</p> <p>This is a FILE-FIRST strategy that downloads an installer from a fixed HTTP(S) URL and extracts version information from the downloaded file. Uses HTTP ETag conditional requests to avoid re-downloading unchanged files.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--key-advantages","title":"Key Advantages","text":"<ul> <li>Works with any fixed URL (version not required in URL)</li> <li>Extracts accurate version directly from installer metadata</li> <li>Uses ETag-based conditional requests for efficiency (~500ms vs full download)</li> <li>Simple and reliable for vendors with stable download URLs</li> <li>Fallback strategy when version not available via API/URL pattern</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--supported-version-extraction","title":"Supported Version Extraction","text":"<ul> <li>msi_product_version_from_file: Extract ProductVersion property from MSI</li> <li>(Future) exe_file_version: Extract FileVersion from PE headers</li> <li>(Future) manual_version: Use a version specified in the recipe</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--use-cases","title":"Use Cases","text":"<ul> <li>Google Chrome: Fixed enterprise MSI URL, version embedded in MSI</li> <li>Mozilla Firefox: Fixed enterprise MSI URL, version embedded in MSI</li> <li>Vendors with stable download URLs and embedded version metadata</li> <li>When version not available via API, URL pattern, or GitHub tags</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--recipe-configuration","title":"Recipe Configuration","text":"<p>source:   strategy: http_static   url: \"https://vendor.com/installer.msi\"          # Required: download URL   version:     type: msi_product_version_from_file            # Required: extraction method     file: \"installer.msi\"                          # Optional: defaults to URL filename</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--configuration-fields","title":"Configuration Fields","text":"<p>url : str     HTTP(S) URL to download the installer from. This is a required field.     The URL should be stable and point to the latest version.</p> <p>version.type : str     Version extraction method. Currently supported: msi_product_version_from_file.     This is a required field.</p> <p>version.file : str, optional     Specific filename to extract version from. Defaults to the downloaded filename     derived from the URL or Content-Disposition header.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--workflow-file-first-with-etag-optimization","title":"Workflow (File-First with ETag Optimization)","text":"<ol> <li>Make conditional HTTP request with cached ETag (If-None-Match header)</li> <li>Server responds with HTTP 304 Not Modified -&gt; use cached file (~500ms)</li> <li>Server responds with HTTP 200 OK -&gt; download new version</li> <li>Extract version from downloaded file based on source.version.type</li> <li>Return DiscoveredVersion, file path, and SHA-256 hash</li> </ol>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--error-handling","title":"Error Handling","text":"<ul> <li>ValueError: Missing or invalid configuration fields</li> <li>RuntimeError: Download failures, version extraction errors</li> <li>Errors are chained with 'from err' for better debugging</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--architecture-file-first-vs-version-first","title":"Architecture: File-First vs Version-First","text":"<ul> <li>http_static (FILE-FIRST): Downloads file first, then extracts version</li> <li>Method: discover_version() -&gt; tuple with DiscoveredVersion</li> <li>Uses: HTTP ETag conditional requests for optimization</li> <li>Pros: Works with any URL, accurate version from installer</li> <li>Cons: Must download to know version (~500ms even with 304)</li> <li> <p>Best for: Fixed URLs with embedded version metadata</p> </li> <li> <p>url_regex, github_release, http_json (VERSION-FIRST): Version before download</p> </li> <li>Method: get_version_info() -&gt; VersionInfo</li> <li>Uses: Version comparison to skip downloads entirely</li> <li>Pros: Instant or fast checks (regex/API only), can skip downloads</li> <li>Cons: Requires version available via API/URL pattern</li> <li>Best for: Version-encoded URLs, APIs, CI/CD with frequent checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--example","title":"Example","text":"<p>In a recipe YAML:</p> <pre><code>apps:\n  - name: \"My App\"\n    id: \"my-app\"\n    source:\n      strategy: http_static\n      url: \"https://example.com/myapp-setup.msi\"\n      version:\n        type: msi_product_version_from_file\n</code></pre> <p>From Python:</p> <pre><code>from pathlib import Path\nfrom notapkgtool.discovery.http_static import HttpStaticStrategy\n\nstrategy = HttpStaticStrategy()\napp_config = {\n    \"source\": {\n        \"url\": \"https://example.com/app.msi\",\n        \"version\": {\"type\": \"msi_product_version_from_file\"},\n    }\n}\n\n# With cache for ETag optimization\ncache = {\"etag\": 'W/\"abc123\"', \"sha256\": \"...\"}\ndiscovered, file_path, sha256, headers = strategy.discover_version(\n    app_config, Path(\"./downloads\"), cache=cache\n)\nprint(f\"Version {discovered.version} at {file_path}\")\n</code></pre> <p>From Python (using core orchestration):</p> <pre><code>from pathlib import Path\nfrom notapkgtool.core import discover_recipe\n\n# Automatically uses ETag optimization\nresult = discover_recipe(Path(\"recipe.yaml\"), Path(\"./downloads\"))\nprint(f\"Version {result['version']} at {result['file_path']}\")\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.http_static--notes","title":"Notes","text":"<ul> <li>Must download file to extract version (architectural constraint)</li> <li>ETag optimization reduces bandwidth but still requires network round-trip</li> <li>Core orchestration automatically provides cached ETag if available</li> <li>Server must support ETag or Last-Modified headers for optimization</li> <li>If server doesn't support conditional requests, full download occurs every time</li> <li>Consider version-first strategies (url_regex, github_release, http_json) for   better performance when version available via API or URL pattern</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy","title":"<code>HttpStaticStrategy</code>","text":"<p>Discovery strategy for static HTTP(S) URLs.</p> Configuration example <p>source:   strategy: http_static   url: \"https://example.com/installer.msi\"   version:     type: msi_product_version_from_file     file: \"installer.msi\"</p> Source code in <code>notapkgtool/discovery/http_static.py</code> <pre><code>class HttpStaticStrategy:\n    \"\"\"\n    Discovery strategy for static HTTP(S) URLs.\n\n    Configuration example:\n        source:\n          strategy: http_static\n          url: \"https://example.com/installer.msi\"\n          version:\n            type: msi_product_version_from_file\n            file: \"installer.msi\"\n    \"\"\"\n\n    def discover_version(\n        self,\n        app_config: dict[str, Any],\n        output_dir: Path,\n        cache: dict[str, Any] | None = None,\n        verbose: bool = False,\n        debug: bool = False,\n    ) -&gt; tuple[DiscoveredVersion, Path, str, dict]:\n        \"\"\"\n        Download from static URL and extract version from the file.\n\n        Parameters\n        ----------\n        app_config : dict\n            App configuration containing source.url and source.version.\n        output_dir : Path\n            Directory to save the downloaded file.\n        cache : dict, optional\n            Cached state with etag, last_modified, file_path, and sha256\n            for conditional requests. If provided and file is unchanged\n            (HTTP 304), the cached file is returned.\n\n        Returns\n        -------\n        tuple[DiscoveredVersion, Path, str, dict]\n            Version info, file path, SHA-256 hash, and HTTP response headers.\n\n        Raises\n        ------\n        ValueError\n            If required config fields are missing or invalid.\n        RuntimeError\n            If download or version extraction fails.\n        \"\"\"\n        from notapkgtool.cli import print_verbose\n\n        source = app_config.get(\"source\", {})\n        url = source.get(\"url\")\n        if not url:\n            raise ValueError(\"http_static strategy requires 'source.url' in config\")\n\n        version_config = source.get(\"version\", {})\n        version_type = version_config.get(\"type\")\n        if not version_type:\n            raise ValueError(\n                \"http_static strategy requires 'source.version.type' in config\"\n            )\n\n        print_verbose(\"DISCOVERY\", \"Strategy: http_static\")\n        print_verbose(\"DISCOVERY\", f\"Source URL: {url}\")\n        print_verbose(\"DISCOVERY\", f\"Version extraction: {version_type}\")\n\n        # Extract ETag/Last-Modified from cache if available\n        etag = cache.get(\"etag\") if cache else None\n        last_modified = cache.get(\"last_modified\") if cache else None\n\n        if etag:\n            print_verbose(\"DISCOVERY\", f\"Using cached ETag: {etag}\")\n        if last_modified:\n            print_verbose(\"DISCOVERY\", f\"Using cached Last-Modified: {last_modified}\")\n\n        # Download the file (with conditional request if cache available)\n        try:\n            file_path, sha256, headers = download_file(\n                url,\n                output_dir,\n                etag=etag,\n                last_modified=last_modified,\n                verbose=verbose,\n                debug=debug,\n            )\n        except NotModifiedError:\n            # File unchanged (HTTP 304), use cached version\n            # Use convention-based path: derive filename from URL\n            print_verbose(\n                \"DISCOVERY\", \"File not modified (HTTP 304), using cached version\"\n            )\n\n            if not cache or \"sha256\" not in cache:\n                raise RuntimeError(\n                    \"Cache indicates file not modified, but missing SHA-256. \"\n                    \"Try running with --stateless to force re-download.\"\n                ) from None\n\n            # Derive file path from URL (convention-based, schema v2)\n            from urllib.parse import urlparse\n\n            filename = Path(urlparse(url).path).name\n            cached_file = output_dir / filename\n\n            if not cached_file.exists():\n                raise RuntimeError(\n                    f\"Cached file {cached_file} not found. \"\n                    f\"File may have been deleted. Try running with --stateless.\"\n                ) from None\n\n            # Extract version from cached file\n            if version_type == \"msi_product_version_from_file\":\n                try:\n                    discovered = version_from_msi_product_version(\n                        cached_file, verbose=verbose, debug=debug\n                    )\n                except Exception as err:\n                    raise RuntimeError(\n                        f\"Failed to extract MSI ProductVersion from cached file {cached_file}: {err}\"\n                    ) from err\n            else:\n                raise ValueError(\n                    f\"Unsupported version type: {version_type!r}. \"\n                    f\"Supported: msi_product_version_from_file\"\n                ) from None\n\n            # Return cached info with preserved headers (prevents overwriting ETag)\n            # When 304, no new headers received, so return cached values to preserve them\n            preserved_headers = {}\n            if cache.get(\"etag\"):\n                preserved_headers[\"ETag\"] = cache[\"etag\"]\n            if cache.get(\"last_modified\"):\n                preserved_headers[\"Last-Modified\"] = cache[\"last_modified\"]\n\n            return discovered, cached_file, cache[\"sha256\"], preserved_headers\n        except Exception as err:\n            if isinstance(err, (RuntimeError, ValueError)):\n                raise\n            raise RuntimeError(f\"Failed to download {url}: {err}\") from err\n\n        # File was downloaded (not cached), extract version from it\n        if version_type == \"msi_product_version_from_file\":\n            try:\n                discovered = version_from_msi_product_version(\n                    file_path, verbose=verbose, debug=debug\n                )\n            except Exception as err:\n                raise RuntimeError(\n                    f\"Failed to extract MSI ProductVersion from {file_path}: {err}\"\n                ) from err\n        else:\n            raise ValueError(\n                f\"Unsupported version type: {version_type!r}. \"\n                f\"Supported: msi_product_version_from_file\"\n            )\n\n        return discovered, file_path, sha256, headers\n\n    def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n        \"\"\"\n        Validate http_static strategy configuration.\n\n        Checks for required fields and correct types without making network calls.\n\n        Parameters\n        ----------\n        app_config : dict\n            The app configuration from the recipe.\n\n        Returns\n        -------\n        list[str]\n            List of error messages (empty if valid).\n        \"\"\"\n        errors = []\n        source = app_config.get(\"source\", {})\n\n        # Check required fields\n        if \"url\" not in source:\n            errors.append(\"Missing required field: source.url\")\n        elif not isinstance(source[\"url\"], str):\n            errors.append(\"source.url must be a string\")\n        elif not source[\"url\"].strip():\n            errors.append(\"source.url cannot be empty\")\n\n        # Check version configuration\n        if \"version\" not in source:\n            errors.append(\"Missing required field: source.version\")\n        elif not isinstance(source[\"version\"], dict):\n            errors.append(\"source.version must be a dictionary\")\n        else:\n            version_config = source[\"version\"]\n\n            # Check version.type\n            if \"type\" not in version_config:\n                errors.append(\"Missing required field: source.version.type\")\n            elif not isinstance(version_config[\"type\"], str):\n                errors.append(\"source.version.type must be a string\")\n            else:\n                version_type = version_config[\"type\"]\n                supported_types = [\"msi_product_version_from_file\"]\n                if version_type not in supported_types:\n                    errors.append(\n                        f\"Unsupported source.version.type: {version_type!r}. \"\n                        f\"Supported: {', '.join(supported_types)}\"\n                    )\n\n        return errors\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy.discover_version","title":"<code>discover_version(app_config, output_dir, cache=None, verbose=False, debug=False)</code>","text":"<p>Download from static URL and extract version from the file.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy.discover_version--parameters","title":"Parameters","text":"<p>app_config : dict     App configuration containing source.url and source.version. output_dir : Path     Directory to save the downloaded file. cache : dict, optional     Cached state with etag, last_modified, file_path, and sha256     for conditional requests. If provided and file is unchanged     (HTTP 304), the cached file is returned.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy.discover_version--returns","title":"Returns","text":"<p>tuple[DiscoveredVersion, Path, str, dict]     Version info, file path, SHA-256 hash, and HTTP response headers.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy.discover_version--raises","title":"Raises","text":"<p>ValueError     If required config fields are missing or invalid. RuntimeError     If download or version extraction fails.</p> Source code in <code>notapkgtool/discovery/http_static.py</code> <pre><code>def discover_version(\n    self,\n    app_config: dict[str, Any],\n    output_dir: Path,\n    cache: dict[str, Any] | None = None,\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; tuple[DiscoveredVersion, Path, str, dict]:\n    \"\"\"\n    Download from static URL and extract version from the file.\n\n    Parameters\n    ----------\n    app_config : dict\n        App configuration containing source.url and source.version.\n    output_dir : Path\n        Directory to save the downloaded file.\n    cache : dict, optional\n        Cached state with etag, last_modified, file_path, and sha256\n        for conditional requests. If provided and file is unchanged\n        (HTTP 304), the cached file is returned.\n\n    Returns\n    -------\n    tuple[DiscoveredVersion, Path, str, dict]\n        Version info, file path, SHA-256 hash, and HTTP response headers.\n\n    Raises\n    ------\n    ValueError\n        If required config fields are missing or invalid.\n    RuntimeError\n        If download or version extraction fails.\n    \"\"\"\n    from notapkgtool.cli import print_verbose\n\n    source = app_config.get(\"source\", {})\n    url = source.get(\"url\")\n    if not url:\n        raise ValueError(\"http_static strategy requires 'source.url' in config\")\n\n    version_config = source.get(\"version\", {})\n    version_type = version_config.get(\"type\")\n    if not version_type:\n        raise ValueError(\n            \"http_static strategy requires 'source.version.type' in config\"\n        )\n\n    print_verbose(\"DISCOVERY\", \"Strategy: http_static\")\n    print_verbose(\"DISCOVERY\", f\"Source URL: {url}\")\n    print_verbose(\"DISCOVERY\", f\"Version extraction: {version_type}\")\n\n    # Extract ETag/Last-Modified from cache if available\n    etag = cache.get(\"etag\") if cache else None\n    last_modified = cache.get(\"last_modified\") if cache else None\n\n    if etag:\n        print_verbose(\"DISCOVERY\", f\"Using cached ETag: {etag}\")\n    if last_modified:\n        print_verbose(\"DISCOVERY\", f\"Using cached Last-Modified: {last_modified}\")\n\n    # Download the file (with conditional request if cache available)\n    try:\n        file_path, sha256, headers = download_file(\n            url,\n            output_dir,\n            etag=etag,\n            last_modified=last_modified,\n            verbose=verbose,\n            debug=debug,\n        )\n    except NotModifiedError:\n        # File unchanged (HTTP 304), use cached version\n        # Use convention-based path: derive filename from URL\n        print_verbose(\n            \"DISCOVERY\", \"File not modified (HTTP 304), using cached version\"\n        )\n\n        if not cache or \"sha256\" not in cache:\n            raise RuntimeError(\n                \"Cache indicates file not modified, but missing SHA-256. \"\n                \"Try running with --stateless to force re-download.\"\n            ) from None\n\n        # Derive file path from URL (convention-based, schema v2)\n        from urllib.parse import urlparse\n\n        filename = Path(urlparse(url).path).name\n        cached_file = output_dir / filename\n\n        if not cached_file.exists():\n            raise RuntimeError(\n                f\"Cached file {cached_file} not found. \"\n                f\"File may have been deleted. Try running with --stateless.\"\n            ) from None\n\n        # Extract version from cached file\n        if version_type == \"msi_product_version_from_file\":\n            try:\n                discovered = version_from_msi_product_version(\n                    cached_file, verbose=verbose, debug=debug\n                )\n            except Exception as err:\n                raise RuntimeError(\n                    f\"Failed to extract MSI ProductVersion from cached file {cached_file}: {err}\"\n                ) from err\n        else:\n            raise ValueError(\n                f\"Unsupported version type: {version_type!r}. \"\n                f\"Supported: msi_product_version_from_file\"\n            ) from None\n\n        # Return cached info with preserved headers (prevents overwriting ETag)\n        # When 304, no new headers received, so return cached values to preserve them\n        preserved_headers = {}\n        if cache.get(\"etag\"):\n            preserved_headers[\"ETag\"] = cache[\"etag\"]\n        if cache.get(\"last_modified\"):\n            preserved_headers[\"Last-Modified\"] = cache[\"last_modified\"]\n\n        return discovered, cached_file, cache[\"sha256\"], preserved_headers\n    except Exception as err:\n        if isinstance(err, (RuntimeError, ValueError)):\n            raise\n        raise RuntimeError(f\"Failed to download {url}: {err}\") from err\n\n    # File was downloaded (not cached), extract version from it\n    if version_type == \"msi_product_version_from_file\":\n        try:\n            discovered = version_from_msi_product_version(\n                file_path, verbose=verbose, debug=debug\n            )\n        except Exception as err:\n            raise RuntimeError(\n                f\"Failed to extract MSI ProductVersion from {file_path}: {err}\"\n            ) from err\n    else:\n        raise ValueError(\n            f\"Unsupported version type: {version_type!r}. \"\n            f\"Supported: msi_product_version_from_file\"\n        )\n\n    return discovered, file_path, sha256, headers\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy.validate_config","title":"<code>validate_config(app_config)</code>","text":"<p>Validate http_static strategy configuration.</p> <p>Checks for required fields and correct types without making network calls.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy.validate_config--parameters","title":"Parameters","text":"<p>app_config : dict     The app configuration from the recipe.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_static.HttpStaticStrategy.validate_config--returns","title":"Returns","text":"<p>list[str]     List of error messages (empty if valid).</p> Source code in <code>notapkgtool/discovery/http_static.py</code> <pre><code>def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n    \"\"\"\n    Validate http_static strategy configuration.\n\n    Checks for required fields and correct types without making network calls.\n\n    Parameters\n    ----------\n    app_config : dict\n        The app configuration from the recipe.\n\n    Returns\n    -------\n    list[str]\n        List of error messages (empty if valid).\n    \"\"\"\n    errors = []\n    source = app_config.get(\"source\", {})\n\n    # Check required fields\n    if \"url\" not in source:\n        errors.append(\"Missing required field: source.url\")\n    elif not isinstance(source[\"url\"], str):\n        errors.append(\"source.url must be a string\")\n    elif not source[\"url\"].strip():\n        errors.append(\"source.url cannot be empty\")\n\n    # Check version configuration\n    if \"version\" not in source:\n        errors.append(\"Missing required field: source.version\")\n    elif not isinstance(source[\"version\"], dict):\n        errors.append(\"source.version must be a dictionary\")\n    else:\n        version_config = source[\"version\"]\n\n        # Check version.type\n        if \"type\" not in version_config:\n            errors.append(\"Missing required field: source.version.type\")\n        elif not isinstance(version_config[\"type\"], str):\n            errors.append(\"source.version.type must be a string\")\n        else:\n            version_type = version_config[\"type\"]\n            supported_types = [\"msi_product_version_from_file\"]\n            if version_type not in supported_types:\n                errors.append(\n                    f\"Unsupported source.version.type: {version_type!r}. \"\n                    f\"Supported: {', '.join(supported_types)}\"\n                )\n\n    return errors\n</code></pre>"},{"location":"api/discovery/#url-regex-strategy","title":"URL Regex Strategy","text":""},{"location":"api/discovery/#notapkgtool.discovery.url_regex","title":"<code>notapkgtool.discovery.url_regex</code>","text":"<p>URL regex discovery strategy for NAPT.</p> <p>This is a VERSION-FIRST strategy that extracts version information directly from the download URL using regular expressions, WITHOUT downloading. This enables instant version checks and efficient caching.</p>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--key-advantages","title":"Key Advantages","text":"<ul> <li>Instant version discovery (regex only, zero network calls)</li> <li>Can skip downloads entirely when version unchanged</li> <li>Works with any file type (MSI, EXE, DMG, etc.)</li> <li>No file parsing overhead</li> <li>Ideal for CI/CD with scheduled checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--supported-version-extraction","title":"Supported Version Extraction","text":"<ul> <li>regex_in_url: Extract version from URL using a regex pattern</li> <li>Supports named capture groups: (?P...) <li>Falls back to full match if no named group</li>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--use-cases","title":"Use Cases","text":"<ul> <li>Vendors with version-encoded download URLs   Example: https://vendor.com/app-v1.2.3-installer.msi</li> <li>API endpoints that return version-specific download links   Example: https://api.vendor.com/download/2024.10.28/setup.exe</li> <li>URLs with predictable version patterns in the path</li> <li>CI/CD pipelines with frequent version checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--recipe-configuration","title":"Recipe Configuration","text":"<p>source:   strategy: url_regex   url: \"https://vendor.com/downloads/app-v1.2.3-setup.msi\"   version:     type: regex_in_url     pattern: \"app-v(?P[0-9.]+)-setup\" <p>The pattern supports full Python regex syntax. Use a named capture group (?P) to extract only the version portion, or let the entire match be used as the version."},{"location":"api/discovery/#notapkgtool.discovery.url_regex--workflow-version-first","title":"Workflow (Version-First)","text":"<ol> <li>Extract version from URL using regex pattern (instant)</li> <li>Create VersionInfo with version and download URL</li> <li>Core orchestration compares version to cache</li> <li>If match and file exists -&gt; skip download entirely</li> <li>If changed or missing -&gt; download from URL</li> </ol>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--error-handling","title":"Error Handling","text":"<ul> <li>ValueError: Missing or invalid configuration fields, pattern doesn't match</li> <li>re.error: Invalid regex patterns (propagates from regex compilation)</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--architecture-version-first-vs-file-first","title":"Architecture: Version-First vs File-First","text":"<ul> <li>url_regex (VERSION-FIRST): Extracts version from URL before download</li> <li>Method: get_version_info() -&gt; VersionInfo</li> <li>Pros: Instant checks, can skip downloads when unchanged</li> <li>Cons: Requires predictable URL patterns</li> <li> <p>Best for: Version-encoded URLs, frequent update checks</p> </li> <li> <p>http_static (FILE-FIRST): Downloads file first, then extracts version</p> </li> <li>Method: discover_version() -&gt; tuple with DiscoveredVersion</li> <li>Pros: Works with any URL, accurate version from installer</li> <li>Cons: Must download to know version</li> <li>Best for: Fixed URLs with embedded version metadata</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--example","title":"Example","text":"<p>In a recipe YAML:</p> <pre><code>apps:\n  - name: \"My App\"\n    id: \"my-app\"\n    source:\n      strategy: url_regex\n      url: \"https://example.com/myapp-v2.1.0-setup.msi\"\n      version:\n        type: regex_in_url\n        pattern: \"myapp-v(?P&lt;version&gt;[0-9.]+)-setup\"\n</code></pre> <p>From Python (version-first approach):</p> <pre><code>from notapkgtool.discovery.url_regex import UrlRegexStrategy\nfrom notapkgtool.io import download_file\n\nstrategy = UrlRegexStrategy()\napp_config = {\n    \"source\": {\n        \"url\": \"https://example.com/app-v1.2.3.msi\",\n        \"version\": {\n            \"type\": \"regex_in_url\",\n            \"pattern\": r\"app-v(?P&lt;version&gt;[0-9.]+)\\.msi\",\n        },\n    }\n}\n\n# Get version WITHOUT downloading\nversion_info = strategy.get_version_info(app_config)\nprint(f\"Latest version: {version_info.version}\")\n\n# Download only if needed\nif need_to_download:\n    file_path, sha256, headers = download_file(\n        version_info.download_url, Path(\"./downloads\")\n    )\n    print(f\"Downloaded to {file_path}\")\n</code></pre> <p>From Python (using core orchestration):</p> <pre><code>from pathlib import Path\nfrom notapkgtool.core import discover_recipe\n\n# Automatically uses version-first optimization\nresult = discover_recipe(Path(\"recipe.yaml\"), Path(\"./downloads\"))\nprint(f\"Version {result['version']} at {result['file_path']}\")\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex--notes","title":"Notes","text":"<ul> <li>Version extraction happens WITHOUT download (instant)</li> <li>Core orchestration automatically skips download if version unchanged</li> <li>The URL pattern must be stable and predictable</li> <li>Pattern matching is case-sensitive by default (use (?i) for case-insensitive)</li> <li>Consider http_static if URLs don't contain version information</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy","title":"<code>UrlRegexStrategy</code>","text":"<p>Discovery strategy for extracting version from URL patterns.</p> Configuration example <p>source:   strategy: url_regex   url: \"https://vendor.com/app-v1.2.3-installer.msi\"   version:     type: regex_in_url     pattern: \"app-v(?P[0-9.]+)-installer\" Source code in <code>notapkgtool/discovery/url_regex.py</code> <pre><code>class UrlRegexStrategy:\n    \"\"\"\n    Discovery strategy for extracting version from URL patterns.\n\n    Configuration example:\n        source:\n          strategy: url_regex\n          url: \"https://vendor.com/app-v1.2.3-installer.msi\"\n          version:\n            type: regex_in_url\n            pattern: \"app-v(?P&lt;version&gt;[0-9.]+)-installer\"\n    \"\"\"\n\n    def get_version_info(\n        self,\n        app_config: dict[str, Any],\n        verbose: bool = False,\n        debug: bool = False,\n    ) -&gt; VersionInfo:\n        \"\"\"\n        Extract version from URL without downloading (version-first path).\n\n        This method enables fast version checking by extracting the version\n        directly from the URL pattern. If the version matches cached state,\n        the download can be skipped entirely.\n\n        Parameters\n        ----------\n        app_config : dict\n            App configuration containing source.url, source.version.type,\n            and source.version.pattern.\n        verbose : bool, optional\n            If True, print verbose logging messages. Default is False.\n        debug : bool, optional\n            If True, print debug logging messages. Default is False.\n\n        Returns\n        -------\n        VersionInfo\n            Version info with version string, download URL, and source name.\n\n        Raises\n        ------\n        ValueError\n            If required config fields are missing, invalid, or if the regex\n            pattern doesn't match the URL.\n\n        Examples\n        --------\n        &gt;&gt;&gt; strategy = UrlRegexStrategy()\n        &gt;&gt;&gt; config = {\n        ...     \"source\": {\n        ...         \"url\": \"https://vendor.com/app-v1.0.0.msi\",\n        ...         \"version\": {\n        ...             \"type\": \"regex_in_url\",\n        ...             \"pattern\": \"app-v(?P&lt;version&gt;[0-9.]+)\\\\\\\\.msi\"\n        ...         }\n        ...     }\n        ... }\n        &gt;&gt;&gt; version_info = strategy.get_version_info(config)\n        &gt;&gt;&gt; version_info.version\n        '1.0.0'\n        \"\"\"\n        from notapkgtool.cli import print_verbose\n\n        # Validate configuration\n        source = app_config.get(\"source\", {})\n        url = source.get(\"url\")\n        if not url:\n            raise ValueError(\"url_regex strategy requires 'source.url' in config\")\n\n        version_config = source.get(\"version\", {})\n        version_type = version_config.get(\"type\")\n        if not version_type:\n            raise ValueError(\n                \"url_regex strategy requires 'source.version.type' in config\"\n            )\n\n        if version_type != \"regex_in_url\":\n            raise ValueError(\n                f\"url_regex strategy requires version.type='regex_in_url', \"\n                f\"got {version_type!r}\"\n            )\n\n        pattern = version_config.get(\"pattern\")\n        if not pattern:\n            raise ValueError(\n                \"url_regex strategy requires 'source.version.pattern' in config\"\n            )\n\n        print_verbose(\"DISCOVERY\", \"Strategy: url_regex (version-first)\")\n        print_verbose(\"DISCOVERY\", f\"Source URL: {url}\")\n        print_verbose(\"DISCOVERY\", f\"Regex pattern: {pattern}\")\n\n        # Extract version from URL (no download needed!)\n        try:\n            discovered = version_from_regex_in_url(\n                url, pattern, verbose=verbose, debug=debug\n            )\n        except ValueError as err:\n            raise ValueError(\n                f\"Failed to extract version from URL using regex: {err}\"\n            ) from err\n\n        print_verbose(\"DISCOVERY\", f\"Discovered version: {discovered.version}\")\n\n        return VersionInfo(\n            version=discovered.version,\n            download_url=url,\n            source=\"url_regex\",\n        )\n\n    def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n        \"\"\"\n        Validate url_regex strategy configuration.\n\n        Checks for required fields and correct types without making network calls.\n\n        Parameters\n        ----------\n        app_config : dict\n            The app configuration from the recipe.\n\n        Returns\n        -------\n        list[str]\n            List of error messages (empty if valid).\n        \"\"\"\n        errors = []\n        source = app_config.get(\"source\", {})\n\n        # Check required fields\n        if \"url\" not in source:\n            errors.append(\"Missing required field: source.url\")\n        elif not isinstance(source[\"url\"], str):\n            errors.append(\"source.url must be a string\")\n        elif not source[\"url\"].strip():\n            errors.append(\"source.url cannot be empty\")\n\n        if \"pattern\" not in source:\n            errors.append(\"Missing required field: source.pattern\")\n        elif not isinstance(source[\"pattern\"], str):\n            errors.append(\"source.pattern must be a string\")\n        elif not source[\"pattern\"].strip():\n            errors.append(\"source.pattern cannot be empty\")\n        else:\n            # Validate regex pattern syntax\n            pattern = source[\"pattern\"]\n            if \"(?P&lt;version&gt;\" not in pattern:\n                errors.append(\n                    \"source.pattern must contain named group (?P&lt;version&gt;...)\"\n                )\n            else:\n                # Try to compile the regex to check syntax\n                import re\n\n                try:\n                    re.compile(pattern)\n                except re.error as err:\n                    errors.append(f\"Invalid regex pattern: {err}\")\n\n        return errors\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.get_version_info","title":"<code>get_version_info(app_config, verbose=False, debug=False)</code>","text":"<p>Extract version from URL without downloading (version-first path).</p> <p>This method enables fast version checking by extracting the version directly from the URL pattern. If the version matches cached state, the download can be skipped entirely.</p>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.get_version_info--parameters","title":"Parameters","text":"<p>app_config : dict     App configuration containing source.url, source.version.type,     and source.version.pattern. verbose : bool, optional     If True, print verbose logging messages. Default is False. debug : bool, optional     If True, print debug logging messages. Default is False.</p>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.get_version_info--returns","title":"Returns","text":"<p>VersionInfo     Version info with version string, download URL, and source name.</p>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.get_version_info--raises","title":"Raises","text":"<p>ValueError     If required config fields are missing, invalid, or if the regex     pattern doesn't match the URL.</p>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.get_version_info--examples","title":"Examples","text":"<p>strategy = UrlRegexStrategy() config = { ...     \"source\": { ...         \"url\": \"https://vendor.com/app-v1.0.0.msi\", ...         \"version\": { ...             \"type\": \"regex_in_url\", ...             \"pattern\": \"app-v(?P[0-9.]+)\\.msi\" ...         } ...     } ... } version_info = strategy.get_version_info(config) version_info.version '1.0.0' Source code in <code>notapkgtool/discovery/url_regex.py</code> <pre><code>def get_version_info(\n    self,\n    app_config: dict[str, Any],\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; VersionInfo:\n    \"\"\"\n    Extract version from URL without downloading (version-first path).\n\n    This method enables fast version checking by extracting the version\n    directly from the URL pattern. If the version matches cached state,\n    the download can be skipped entirely.\n\n    Parameters\n    ----------\n    app_config : dict\n        App configuration containing source.url, source.version.type,\n        and source.version.pattern.\n    verbose : bool, optional\n        If True, print verbose logging messages. Default is False.\n    debug : bool, optional\n        If True, print debug logging messages. Default is False.\n\n    Returns\n    -------\n    VersionInfo\n        Version info with version string, download URL, and source name.\n\n    Raises\n    ------\n    ValueError\n        If required config fields are missing, invalid, or if the regex\n        pattern doesn't match the URL.\n\n    Examples\n    --------\n    &gt;&gt;&gt; strategy = UrlRegexStrategy()\n    &gt;&gt;&gt; config = {\n    ...     \"source\": {\n    ...         \"url\": \"https://vendor.com/app-v1.0.0.msi\",\n    ...         \"version\": {\n    ...             \"type\": \"regex_in_url\",\n    ...             \"pattern\": \"app-v(?P&lt;version&gt;[0-9.]+)\\\\\\\\.msi\"\n    ...         }\n    ...     }\n    ... }\n    &gt;&gt;&gt; version_info = strategy.get_version_info(config)\n    &gt;&gt;&gt; version_info.version\n    '1.0.0'\n    \"\"\"\n    from notapkgtool.cli import print_verbose\n\n    # Validate configuration\n    source = app_config.get(\"source\", {})\n    url = source.get(\"url\")\n    if not url:\n        raise ValueError(\"url_regex strategy requires 'source.url' in config\")\n\n    version_config = source.get(\"version\", {})\n    version_type = version_config.get(\"type\")\n    if not version_type:\n        raise ValueError(\n            \"url_regex strategy requires 'source.version.type' in config\"\n        )\n\n    if version_type != \"regex_in_url\":\n        raise ValueError(\n            f\"url_regex strategy requires version.type='regex_in_url', \"\n            f\"got {version_type!r}\"\n        )\n\n    pattern = version_config.get(\"pattern\")\n    if not pattern:\n        raise ValueError(\n            \"url_regex strategy requires 'source.version.pattern' in config\"\n        )\n\n    print_verbose(\"DISCOVERY\", \"Strategy: url_regex (version-first)\")\n    print_verbose(\"DISCOVERY\", f\"Source URL: {url}\")\n    print_verbose(\"DISCOVERY\", f\"Regex pattern: {pattern}\")\n\n    # Extract version from URL (no download needed!)\n    try:\n        discovered = version_from_regex_in_url(\n            url, pattern, verbose=verbose, debug=debug\n        )\n    except ValueError as err:\n        raise ValueError(\n            f\"Failed to extract version from URL using regex: {err}\"\n        ) from err\n\n    print_verbose(\"DISCOVERY\", f\"Discovered version: {discovered.version}\")\n\n    return VersionInfo(\n        version=discovered.version,\n        download_url=url,\n        source=\"url_regex\",\n    )\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.validate_config","title":"<code>validate_config(app_config)</code>","text":"<p>Validate url_regex strategy configuration.</p> <p>Checks for required fields and correct types without making network calls.</p>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.validate_config--parameters","title":"Parameters","text":"<p>app_config : dict     The app configuration from the recipe.</p>"},{"location":"api/discovery/#notapkgtool.discovery.url_regex.UrlRegexStrategy.validate_config--returns","title":"Returns","text":"<p>list[str]     List of error messages (empty if valid).</p> Source code in <code>notapkgtool/discovery/url_regex.py</code> <pre><code>def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n    \"\"\"\n    Validate url_regex strategy configuration.\n\n    Checks for required fields and correct types without making network calls.\n\n    Parameters\n    ----------\n    app_config : dict\n        The app configuration from the recipe.\n\n    Returns\n    -------\n    list[str]\n        List of error messages (empty if valid).\n    \"\"\"\n    errors = []\n    source = app_config.get(\"source\", {})\n\n    # Check required fields\n    if \"url\" not in source:\n        errors.append(\"Missing required field: source.url\")\n    elif not isinstance(source[\"url\"], str):\n        errors.append(\"source.url must be a string\")\n    elif not source[\"url\"].strip():\n        errors.append(\"source.url cannot be empty\")\n\n    if \"pattern\" not in source:\n        errors.append(\"Missing required field: source.pattern\")\n    elif not isinstance(source[\"pattern\"], str):\n        errors.append(\"source.pattern must be a string\")\n    elif not source[\"pattern\"].strip():\n        errors.append(\"source.pattern cannot be empty\")\n    else:\n        # Validate regex pattern syntax\n        pattern = source[\"pattern\"]\n        if \"(?P&lt;version&gt;\" not in pattern:\n            errors.append(\n                \"source.pattern must contain named group (?P&lt;version&gt;...)\"\n            )\n        else:\n            # Try to compile the regex to check syntax\n            import re\n\n            try:\n                re.compile(pattern)\n            except re.error as err:\n                errors.append(f\"Invalid regex pattern: {err}\")\n\n    return errors\n</code></pre>"},{"location":"api/discovery/#github-release-strategy","title":"GitHub Release Strategy","text":""},{"location":"api/discovery/#notapkgtool.discovery.github_release","title":"<code>notapkgtool.discovery.github_release</code>","text":"<p>GitHub releases discovery strategy for NAPT.</p> <p>This is a VERSION-FIRST strategy that queries the GitHub API to get version and download URL WITHOUT downloading the installer. This enables fast version checks and efficient caching.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--key-advantages","title":"Key Advantages","text":"<ul> <li>Fast version discovery (GitHub API call ~100ms)</li> <li>Can skip downloads entirely when version unchanged</li> <li>Direct access to latest releases via stable GitHub API</li> <li>Version extraction from Git tags (semantic versioning friendly)</li> <li>Asset pattern matching for multi-platform releases</li> <li>Optional authentication for higher rate limits</li> <li>No web scraping required</li> <li>Ideal for CI/CD with scheduled checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--supported-version-extraction","title":"Supported Version Extraction","text":"<ul> <li>Tag-based: Extract version from release tag names</li> <li>Supports named capture groups: (?P...) <li>Default pattern strips \"v\" prefix: v1.2.3 \u2192 1.2.3</li> <li>Falls back to full tag if no pattern match</li>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--use-cases","title":"Use Cases","text":"<ul> <li>Open-source projects (Git, VS Code, Node.js, etc.)</li> <li>Projects with GitHub releases (Firefox, Chrome alternatives)</li> <li>Vendors who publish installers as release assets</li> <li>Projects with semantic versioned tags</li> <li>CI/CD pipelines with frequent version checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--recipe-configuration","title":"Recipe Configuration","text":"<p>source:   strategy: github_release   repo: \"git-for-windows/git\"                    # Required: owner/repo   asset_pattern: \"Git-.*-64-bit.exe$\"          # Optional: regex for asset   version_pattern: \"v?([0-9.]+)\"                 # Optional: version extraction   prerelease: false                              # Optional: include prereleases   token: \"${GITHUB_TOKEN}\"                       # Optional: auth token</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--configuration-fields","title":"Configuration Fields","text":"<p>repo : str     GitHub repository in \"owner/name\" format (e.g., \"git-for-windows/git\").     This is the only required field.</p> str, optional <p>Regular expression to match asset filename. If multiple assets match, the first match is used. If omitted, the first asset is selected. Example: \".*-x64.msi$\" matches assets ending with \"-x64.msi\"</p> str, optional <p>Regular expression to extract version from the release tag name. Use a named capture group (?P...) or the entire match. Default: \"v?([0-9.]+)\" strips optional \"v\" prefix. Example: \"release-([0-9.]+)\" for tags like \"release-1.2.3\" bool, optional <p>If True, include pre-release versions. If False (default), only stable releases are considered. Uses GitHub's prerelease flag.</p> str, optional <p>GitHub personal access token for authentication. Increases rate limit from 60 to 5000 requests per hour. Can use environment variable substitution: \"${GITHUB_TOKEN}\". Note: No special permissions needed for public repositories.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--workflow-version-first","title":"Workflow (Version-First)","text":"<ol> <li>Call GitHub API: GET /repos/{owner}/{repo}/releases/latest (~100ms)</li> <li>Extract version from release tag using version_pattern</li> <li>Find matching asset using asset_pattern (or first asset)</li> <li>Create VersionInfo with version and download URL</li> <li>Core orchestration compares version to cache</li> <li>If match and file exists -&gt; skip download entirely</li> <li>If changed or missing -&gt; download from URL</li> </ol>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--error-handling","title":"Error Handling","text":"<ul> <li>ValueError: Missing or invalid configuration fields</li> <li>RuntimeError: API failures, no releases, no matching assets</li> <li>Errors are chained with 'from err' for better debugging</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--rate-limits","title":"Rate Limits","text":"<ul> <li>Unauthenticated: 60 requests/hour per IP</li> <li>Authenticated: 5000 requests/hour per token</li> <li>Tip: Use a token for production use or frequent checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--example","title":"Example","text":"<p>In a recipe YAML:</p> <pre><code>apps:\n  - name: \"Git for Windows\"\n    id: \"git\"\n    source:\n      strategy: github_release\n      repo: \"git-for-windows/git\"\n      asset_pattern: \"Git-.*-64-bit\\.exe$\"\n      version:\n        type: tag  # Version comes from tag, not file\n</code></pre> <p>From Python (version-first approach):</p> <pre><code>from notapkgtool.discovery.github_release import GithubReleaseStrategy\nfrom notapkgtool.io import download_file\n\nstrategy = GithubReleaseStrategy()\napp_config = {\n    \"source\": {\n        \"repo\": \"git-for-windows/git\",\n        \"asset_pattern\": \".*-64-bit\\.exe$\",\n    }\n}\n\n# Get version WITHOUT downloading\nversion_info = strategy.get_version_info(app_config)\nprint(f\"Latest version: {version_info.version}\")\n\n# Download only if needed\nif need_to_download:\n    file_path, sha256, headers = download_file(\n        version_info.download_url, Path(\"./downloads\")\n    )\n    print(f\"Downloaded to {file_path}\")\n</code></pre> <p>From Python (using core orchestration):</p> <pre><code>from pathlib import Path\nfrom notapkgtool.core import discover_recipe\n\n# Automatically uses version-first optimization\nresult = discover_recipe(Path(\"recipe.yaml\"), Path(\"./downloads\"))\nprint(f\"Version {result['version']} at {result['file_path']}\")\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.github_release--notes","title":"Notes","text":"<ul> <li>Version discovery via API only (no download required)</li> <li>Core orchestration automatically skips download if version unchanged</li> <li>The GitHub API is stable and well-documented</li> <li>Releases are fetched in order (latest first)</li> <li>Asset matching is case-sensitive by default (use (?i) for case-insensitive)</li> <li>Consider http_static if you need a direct download URL instead</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy","title":"<code>GithubReleaseStrategy</code>","text":"<p>Discovery strategy for GitHub releases.</p> Configuration example <p>source:   strategy: github_release   repo: \"owner/repository\"   asset_pattern: \".*.msi$\"   version_pattern: \"v?([0-9.]+)\"   prerelease: false   token: \"${GITHUB_TOKEN}\"</p> Source code in <code>notapkgtool/discovery/github_release.py</code> <pre><code>class GithubReleaseStrategy:\n    \"\"\"\n    Discovery strategy for GitHub releases.\n\n    Configuration example:\n        source:\n          strategy: github_release\n          repo: \"owner/repository\"\n          asset_pattern: \".*\\\\.msi$\"\n          version_pattern: \"v?([0-9.]+)\"\n          prerelease: false\n          token: \"${GITHUB_TOKEN}\"\n    \"\"\"\n\n    def get_version_info(\n        self,\n        app_config: dict[str, Any],\n        verbose: bool = False,\n        debug: bool = False,\n    ) -&gt; VersionInfo:\n        \"\"\"\n        Fetch latest release from GitHub API without downloading (version-first path).\n\n        This method queries the GitHub API for the latest release and extracts\n        the version from the tag name and the download URL from matching assets.\n        If the version matches cached state, the download can be skipped entirely.\n\n        Parameters\n        ----------\n        app_config : dict\n            App configuration containing source.repo and optional fields.\n        verbose : bool, optional\n            If True, print verbose logging messages. Default is False.\n        debug : bool, optional\n            If True, print debug logging messages. Default is False.\n\n        Returns\n        -------\n        VersionInfo\n            Version info with version string, download URL, and source name.\n\n        Raises\n        ------\n        ValueError\n            If required config fields are missing, invalid, or if no matching\n            assets are found.\n        RuntimeError\n            If API call fails or release has no assets.\n\n        Examples\n        --------\n        &gt;&gt;&gt; strategy = GithubReleaseStrategy()\n        &gt;&gt;&gt; config = {\n        ...     \"source\": {\n        ...         \"repo\": \"owner/repo\",\n        ...         \"asset_pattern\": \".*\\\\.msi$\"\n        ...     }\n        ... }\n        &gt;&gt;&gt; version_info = strategy.get_version_info(config)\n        &gt;&gt;&gt; version_info.version\n        '1.0.0'\n        \"\"\"\n        from notapkgtool.cli import print_verbose\n\n        # Validate configuration\n        source = app_config.get(\"source\", {})\n        repo = source.get(\"repo\")\n        if not repo:\n            raise ValueError(\"github_release strategy requires 'source.repo' in config\")\n\n        # Validate repo format\n        if \"/\" not in repo or repo.count(\"/\") != 1:\n            raise ValueError(\n                f\"Invalid repo format: {repo!r}. Expected 'owner/repository'\"\n            )\n\n        # Optional configuration\n        asset_pattern = source.get(\"asset_pattern\")\n        version_pattern = source.get(\"version_pattern\", r\"v?([0-9.]+)\")\n        prerelease = source.get(\"prerelease\", False)\n        token = source.get(\"token\")\n\n        # Expand environment variables in token (e.g., ${GITHUB_TOKEN})\n        if token:\n            if token.startswith(\"${\") and token.endswith(\"}\"):\n                env_var = token[2:-1]\n                token = os.environ.get(env_var)\n                if not token:\n                    print_verbose(\n                        \"DISCOVERY\",\n                        f\"Warning: Environment variable {env_var} not set\",\n                    )\n\n        print_verbose(\"DISCOVERY\", \"Strategy: github_release (version-first)\")\n        print_verbose(\"DISCOVERY\", f\"Repository: {repo}\")\n        print_verbose(\"DISCOVERY\", f\"Version pattern: {version_pattern}\")\n        if asset_pattern:\n            print_verbose(\"DISCOVERY\", f\"Asset pattern: {asset_pattern}\")\n        if prerelease:\n            print_verbose(\"DISCOVERY\", \"Including pre-releases\")\n\n        # Fetch latest release from GitHub API\n        api_url = f\"https://api.github.com/repos/{repo}/releases/latest\"\n        headers = {\n            \"Accept\": \"application/vnd.github+json\",\n            \"X-GitHub-Api-Version\": \"2022-11-28\",\n        }\n\n        # Add authentication if token provided\n        if token:\n            headers[\"Authorization\"] = f\"token {token}\"\n            print_verbose(\"DISCOVERY\", \"Using authenticated API request\")\n\n        print_verbose(\"DISCOVERY\", f\"Fetching release from: {api_url}\")\n\n        try:\n            response = requests.get(api_url, headers=headers, timeout=30)\n            response.raise_for_status()\n        except requests.exceptions.HTTPError as err:\n            if response.status_code == 404:\n                raise RuntimeError(\n                    f\"Repository {repo!r} not found or has no releases\"\n                ) from err\n            elif response.status_code == 403:\n                raise RuntimeError(\n                    f\"GitHub API rate limit exceeded. Consider using a token. \"\n                    f\"Status: {response.status_code}\"\n                ) from err\n            else:\n                raise RuntimeError(\n                    f\"GitHub API request failed: {response.status_code} {response.reason}\"\n                ) from err\n        except requests.exceptions.RequestException as err:\n            raise RuntimeError(f\"Failed to fetch GitHub release: {err}\") from err\n\n        release_data = response.json()\n\n        # Check if this is a prerelease and we don't want those\n        if release_data.get(\"prerelease\", False) and not prerelease:\n            raise RuntimeError(\n                f\"Latest release is a pre-release and prerelease=false. \"\n                f\"Tag: {release_data.get('tag_name')}\"\n            )\n\n        # Extract version from tag name\n        tag_name = release_data.get(\"tag_name\", \"\")\n        if not tag_name:\n            raise RuntimeError(\"Release has no tag_name field\")\n\n        print_verbose(\"DISCOVERY\", f\"Release tag: {tag_name}\")\n\n        try:\n            pattern = re.compile(version_pattern)\n            match = pattern.search(tag_name)\n            if not match:\n                raise ValueError(\n                    f\"Version pattern {version_pattern!r} did not match tag {tag_name!r}\"\n                )\n\n            # Try to get named capture group 'version' first, else use group 1, else full match\n            if \"version\" in pattern.groupindex:\n                version_str = match.group(\"version\")\n            elif pattern.groups &gt; 0:\n                version_str = match.group(1)\n            else:\n                version_str = match.group(0)\n\n        except re.error as err:\n            raise ValueError(\n                f\"Invalid version_pattern regex: {version_pattern!r}\"\n            ) from err\n        except (ValueError, IndexError) as err:\n            raise ValueError(\n                f\"Failed to extract version from tag {tag_name!r} \"\n                f\"using pattern {version_pattern!r}: {err}\"\n            ) from err\n\n        print_verbose(\"DISCOVERY\", f\"Extracted version: {version_str}\")\n\n        # Find matching asset\n        assets = release_data.get(\"assets\", [])\n        if not assets:\n            raise RuntimeError(\n                f\"Release {tag_name} has no assets. \"\n                f\"Check if assets were uploaded to the release.\"\n            )\n\n        print_verbose(\"DISCOVERY\", f\"Release has {len(assets)} asset(s)\")\n\n        # Match asset by pattern or take first\n        matched_asset = None\n        if asset_pattern:\n            try:\n                pattern = re.compile(asset_pattern)\n            except re.error as err:\n                raise ValueError(\n                    f\"Invalid asset_pattern regex: {asset_pattern!r}\"\n                ) from err\n\n            for asset in assets:\n                asset_name = asset.get(\"name\", \"\")\n                if pattern.search(asset_name):\n                    matched_asset = asset\n                    print_verbose(\"DISCOVERY\", f\"Matched asset: {asset_name}\")\n                    break\n\n            if not matched_asset:\n                available = [a.get(\"name\", \"(unnamed)\") for a in assets]\n                raise ValueError(\n                    f\"No assets matched pattern {asset_pattern!r}. \"\n                    f\"Available assets: {', '.join(available)}\"\n                )\n        else:\n            matched_asset = assets[0]\n            print_verbose(\n                \"DISCOVERY\",\n                f\"No pattern specified, using first asset: {matched_asset.get('name')}\",\n            )\n\n        # Get download URL\n        download_url = matched_asset.get(\"browser_download_url\")\n        if not download_url:\n            raise RuntimeError(f\"Asset {matched_asset.get('name')} has no download URL\")\n\n        print_verbose(\"DISCOVERY\", f\"Download URL: {download_url}\")\n\n        return VersionInfo(\n            version=version_str,\n            download_url=download_url,\n            source=\"github_release\",\n        )\n\n    def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n        \"\"\"\n        Validate github_release strategy configuration.\n\n        Checks for required fields and correct types without making network calls.\n\n        Parameters\n        ----------\n        app_config : dict\n            The app configuration from the recipe.\n\n        Returns\n        -------\n        list[str]\n            List of error messages (empty if valid).\n        \"\"\"\n        errors = []\n        source = app_config.get(\"source\", {})\n\n        # Check required fields\n        if \"repo\" not in source:\n            errors.append(\"Missing required field: source.repo\")\n        elif not isinstance(source[\"repo\"], str):\n            errors.append(\"source.repo must be a string\")\n        elif not source[\"repo\"].strip():\n            errors.append(\"source.repo cannot be empty\")\n        else:\n            # Validate repo format\n            repo = source[\"repo\"]\n            if repo.count(\"/\") != 1:\n                errors.append(\n                    \"source.repo must be in format 'owner/repo' (e.g., 'git/git')\"\n                )\n\n        if \"asset_pattern\" not in source:\n            errors.append(\"Missing required field: source.asset_pattern\")\n        elif not isinstance(source[\"asset_pattern\"], str):\n            errors.append(\"source.asset_pattern must be a string\")\n        elif not source[\"asset_pattern\"].strip():\n            errors.append(\"source.asset_pattern cannot be empty\")\n        else:\n            # Validate regex pattern syntax\n            pattern = source[\"asset_pattern\"]\n            import re\n\n            try:\n                re.compile(pattern)\n            except re.error as err:\n                errors.append(f\"Invalid asset_pattern regex: {err}\")\n\n        # Optional fields validation\n        if \"version_pattern\" in source:\n            if not isinstance(source[\"version_pattern\"], str):\n                errors.append(\"source.version_pattern must be a string\")\n            else:\n                pattern = source[\"version_pattern\"]\n                import re\n\n                try:\n                    re.compile(pattern)\n                except re.error as err:\n                    errors.append(f\"Invalid version_pattern regex: {err}\")\n\n        return errors\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.get_version_info","title":"<code>get_version_info(app_config, verbose=False, debug=False)</code>","text":"<p>Fetch latest release from GitHub API without downloading (version-first path).</p> <p>This method queries the GitHub API for the latest release and extracts the version from the tag name and the download URL from matching assets. If the version matches cached state, the download can be skipped entirely.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.get_version_info--parameters","title":"Parameters","text":"<p>app_config : dict     App configuration containing source.repo and optional fields. verbose : bool, optional     If True, print verbose logging messages. Default is False. debug : bool, optional     If True, print debug logging messages. Default is False.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.get_version_info--returns","title":"Returns","text":"<p>VersionInfo     Version info with version string, download URL, and source name.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.get_version_info--raises","title":"Raises","text":"<p>ValueError     If required config fields are missing, invalid, or if no matching     assets are found. RuntimeError     If API call fails or release has no assets.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.get_version_info--examples","title":"Examples","text":"<p>strategy = GithubReleaseStrategy() config = { ...     \"source\": { ...         \"repo\": \"owner/repo\", ...         \"asset_pattern\": \".*.msi$\" ...     } ... } version_info = strategy.get_version_info(config) version_info.version '1.0.0'</p> Source code in <code>notapkgtool/discovery/github_release.py</code> <pre><code>def get_version_info(\n    self,\n    app_config: dict[str, Any],\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; VersionInfo:\n    \"\"\"\n    Fetch latest release from GitHub API without downloading (version-first path).\n\n    This method queries the GitHub API for the latest release and extracts\n    the version from the tag name and the download URL from matching assets.\n    If the version matches cached state, the download can be skipped entirely.\n\n    Parameters\n    ----------\n    app_config : dict\n        App configuration containing source.repo and optional fields.\n    verbose : bool, optional\n        If True, print verbose logging messages. Default is False.\n    debug : bool, optional\n        If True, print debug logging messages. Default is False.\n\n    Returns\n    -------\n    VersionInfo\n        Version info with version string, download URL, and source name.\n\n    Raises\n    ------\n    ValueError\n        If required config fields are missing, invalid, or if no matching\n        assets are found.\n    RuntimeError\n        If API call fails or release has no assets.\n\n    Examples\n    --------\n    &gt;&gt;&gt; strategy = GithubReleaseStrategy()\n    &gt;&gt;&gt; config = {\n    ...     \"source\": {\n    ...         \"repo\": \"owner/repo\",\n    ...         \"asset_pattern\": \".*\\\\.msi$\"\n    ...     }\n    ... }\n    &gt;&gt;&gt; version_info = strategy.get_version_info(config)\n    &gt;&gt;&gt; version_info.version\n    '1.0.0'\n    \"\"\"\n    from notapkgtool.cli import print_verbose\n\n    # Validate configuration\n    source = app_config.get(\"source\", {})\n    repo = source.get(\"repo\")\n    if not repo:\n        raise ValueError(\"github_release strategy requires 'source.repo' in config\")\n\n    # Validate repo format\n    if \"/\" not in repo or repo.count(\"/\") != 1:\n        raise ValueError(\n            f\"Invalid repo format: {repo!r}. Expected 'owner/repository'\"\n        )\n\n    # Optional configuration\n    asset_pattern = source.get(\"asset_pattern\")\n    version_pattern = source.get(\"version_pattern\", r\"v?([0-9.]+)\")\n    prerelease = source.get(\"prerelease\", False)\n    token = source.get(\"token\")\n\n    # Expand environment variables in token (e.g., ${GITHUB_TOKEN})\n    if token:\n        if token.startswith(\"${\") and token.endswith(\"}\"):\n            env_var = token[2:-1]\n            token = os.environ.get(env_var)\n            if not token:\n                print_verbose(\n                    \"DISCOVERY\",\n                    f\"Warning: Environment variable {env_var} not set\",\n                )\n\n    print_verbose(\"DISCOVERY\", \"Strategy: github_release (version-first)\")\n    print_verbose(\"DISCOVERY\", f\"Repository: {repo}\")\n    print_verbose(\"DISCOVERY\", f\"Version pattern: {version_pattern}\")\n    if asset_pattern:\n        print_verbose(\"DISCOVERY\", f\"Asset pattern: {asset_pattern}\")\n    if prerelease:\n        print_verbose(\"DISCOVERY\", \"Including pre-releases\")\n\n    # Fetch latest release from GitHub API\n    api_url = f\"https://api.github.com/repos/{repo}/releases/latest\"\n    headers = {\n        \"Accept\": \"application/vnd.github+json\",\n        \"X-GitHub-Api-Version\": \"2022-11-28\",\n    }\n\n    # Add authentication if token provided\n    if token:\n        headers[\"Authorization\"] = f\"token {token}\"\n        print_verbose(\"DISCOVERY\", \"Using authenticated API request\")\n\n    print_verbose(\"DISCOVERY\", f\"Fetching release from: {api_url}\")\n\n    try:\n        response = requests.get(api_url, headers=headers, timeout=30)\n        response.raise_for_status()\n    except requests.exceptions.HTTPError as err:\n        if response.status_code == 404:\n            raise RuntimeError(\n                f\"Repository {repo!r} not found or has no releases\"\n            ) from err\n        elif response.status_code == 403:\n            raise RuntimeError(\n                f\"GitHub API rate limit exceeded. Consider using a token. \"\n                f\"Status: {response.status_code}\"\n            ) from err\n        else:\n            raise RuntimeError(\n                f\"GitHub API request failed: {response.status_code} {response.reason}\"\n            ) from err\n    except requests.exceptions.RequestException as err:\n        raise RuntimeError(f\"Failed to fetch GitHub release: {err}\") from err\n\n    release_data = response.json()\n\n    # Check if this is a prerelease and we don't want those\n    if release_data.get(\"prerelease\", False) and not prerelease:\n        raise RuntimeError(\n            f\"Latest release is a pre-release and prerelease=false. \"\n            f\"Tag: {release_data.get('tag_name')}\"\n        )\n\n    # Extract version from tag name\n    tag_name = release_data.get(\"tag_name\", \"\")\n    if not tag_name:\n        raise RuntimeError(\"Release has no tag_name field\")\n\n    print_verbose(\"DISCOVERY\", f\"Release tag: {tag_name}\")\n\n    try:\n        pattern = re.compile(version_pattern)\n        match = pattern.search(tag_name)\n        if not match:\n            raise ValueError(\n                f\"Version pattern {version_pattern!r} did not match tag {tag_name!r}\"\n            )\n\n        # Try to get named capture group 'version' first, else use group 1, else full match\n        if \"version\" in pattern.groupindex:\n            version_str = match.group(\"version\")\n        elif pattern.groups &gt; 0:\n            version_str = match.group(1)\n        else:\n            version_str = match.group(0)\n\n    except re.error as err:\n        raise ValueError(\n            f\"Invalid version_pattern regex: {version_pattern!r}\"\n        ) from err\n    except (ValueError, IndexError) as err:\n        raise ValueError(\n            f\"Failed to extract version from tag {tag_name!r} \"\n            f\"using pattern {version_pattern!r}: {err}\"\n        ) from err\n\n    print_verbose(\"DISCOVERY\", f\"Extracted version: {version_str}\")\n\n    # Find matching asset\n    assets = release_data.get(\"assets\", [])\n    if not assets:\n        raise RuntimeError(\n            f\"Release {tag_name} has no assets. \"\n            f\"Check if assets were uploaded to the release.\"\n        )\n\n    print_verbose(\"DISCOVERY\", f\"Release has {len(assets)} asset(s)\")\n\n    # Match asset by pattern or take first\n    matched_asset = None\n    if asset_pattern:\n        try:\n            pattern = re.compile(asset_pattern)\n        except re.error as err:\n            raise ValueError(\n                f\"Invalid asset_pattern regex: {asset_pattern!r}\"\n            ) from err\n\n        for asset in assets:\n            asset_name = asset.get(\"name\", \"\")\n            if pattern.search(asset_name):\n                matched_asset = asset\n                print_verbose(\"DISCOVERY\", f\"Matched asset: {asset_name}\")\n                break\n\n        if not matched_asset:\n            available = [a.get(\"name\", \"(unnamed)\") for a in assets]\n            raise ValueError(\n                f\"No assets matched pattern {asset_pattern!r}. \"\n                f\"Available assets: {', '.join(available)}\"\n            )\n    else:\n        matched_asset = assets[0]\n        print_verbose(\n            \"DISCOVERY\",\n            f\"No pattern specified, using first asset: {matched_asset.get('name')}\",\n        )\n\n    # Get download URL\n    download_url = matched_asset.get(\"browser_download_url\")\n    if not download_url:\n        raise RuntimeError(f\"Asset {matched_asset.get('name')} has no download URL\")\n\n    print_verbose(\"DISCOVERY\", f\"Download URL: {download_url}\")\n\n    return VersionInfo(\n        version=version_str,\n        download_url=download_url,\n        source=\"github_release\",\n    )\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.validate_config","title":"<code>validate_config(app_config)</code>","text":"<p>Validate github_release strategy configuration.</p> <p>Checks for required fields and correct types without making network calls.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.validate_config--parameters","title":"Parameters","text":"<p>app_config : dict     The app configuration from the recipe.</p>"},{"location":"api/discovery/#notapkgtool.discovery.github_release.GithubReleaseStrategy.validate_config--returns","title":"Returns","text":"<p>list[str]     List of error messages (empty if valid).</p> Source code in <code>notapkgtool/discovery/github_release.py</code> <pre><code>def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n    \"\"\"\n    Validate github_release strategy configuration.\n\n    Checks for required fields and correct types without making network calls.\n\n    Parameters\n    ----------\n    app_config : dict\n        The app configuration from the recipe.\n\n    Returns\n    -------\n    list[str]\n        List of error messages (empty if valid).\n    \"\"\"\n    errors = []\n    source = app_config.get(\"source\", {})\n\n    # Check required fields\n    if \"repo\" not in source:\n        errors.append(\"Missing required field: source.repo\")\n    elif not isinstance(source[\"repo\"], str):\n        errors.append(\"source.repo must be a string\")\n    elif not source[\"repo\"].strip():\n        errors.append(\"source.repo cannot be empty\")\n    else:\n        # Validate repo format\n        repo = source[\"repo\"]\n        if repo.count(\"/\") != 1:\n            errors.append(\n                \"source.repo must be in format 'owner/repo' (e.g., 'git/git')\"\n            )\n\n    if \"asset_pattern\" not in source:\n        errors.append(\"Missing required field: source.asset_pattern\")\n    elif not isinstance(source[\"asset_pattern\"], str):\n        errors.append(\"source.asset_pattern must be a string\")\n    elif not source[\"asset_pattern\"].strip():\n        errors.append(\"source.asset_pattern cannot be empty\")\n    else:\n        # Validate regex pattern syntax\n        pattern = source[\"asset_pattern\"]\n        import re\n\n        try:\n            re.compile(pattern)\n        except re.error as err:\n            errors.append(f\"Invalid asset_pattern regex: {err}\")\n\n    # Optional fields validation\n    if \"version_pattern\" in source:\n        if not isinstance(source[\"version_pattern\"], str):\n            errors.append(\"source.version_pattern must be a string\")\n        else:\n            pattern = source[\"version_pattern\"]\n            import re\n\n            try:\n                re.compile(pattern)\n            except re.error as err:\n                errors.append(f\"Invalid version_pattern regex: {err}\")\n\n    return errors\n</code></pre>"},{"location":"api/discovery/#http-json-strategy","title":"HTTP JSON Strategy","text":""},{"location":"api/discovery/#notapkgtool.discovery.http_json","title":"<code>notapkgtool.discovery.http_json</code>","text":"<p>HTTP JSON API discovery strategy for NAPT.</p> <p>This is a VERSION-FIRST strategy that queries JSON API endpoints to get version and download URL WITHOUT downloading the installer. This enables fast version checks and efficient caching.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--key-advantages","title":"Key Advantages","text":"<ul> <li>Fast version discovery (API call ~100ms)</li> <li>Can skip downloads entirely when version unchanged</li> <li>Direct API access for version and download URL</li> <li>Support for complex JSON structures with JSONPath</li> <li>Custom headers for authentication</li> <li>Support for GET and POST requests</li> <li>No file parsing required</li> <li>Ideal for CI/CD with scheduled checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--supported-features","title":"Supported Features","text":"<ul> <li>JSONPath navigation for nested structures</li> <li>Array indexing and filtering</li> <li>Custom HTTP headers (Authorization, etc.)</li> <li>POST requests with JSON body</li> <li>Environment variable expansion in values</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--use-cases","title":"Use Cases","text":"<ul> <li>Vendors with JSON APIs (Microsoft, Mozilla, etc.)</li> <li>Cloud services with version endpoints</li> <li>CDNs that provide metadata APIs</li> <li>Applications with update check APIs</li> <li>APIs requiring authentication or custom headers</li> <li>CI/CD pipelines with frequent version checks</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--recipe-configuration","title":"Recipe Configuration","text":"<p>source:   strategy: http_json   api_url: \"https://vendor.com/api/latest\"   version_path: \"version\"                      # JSONPath to version   download_url_path: \"download_url\"            # JSONPath to URL   method: \"GET\"                                # Optional: GET or POST   headers:                                     # Optional: custom headers     Authorization: \"Bearer ${API_TOKEN}\"     Accept: \"application/json\"   body:                                        # Optional: POST body     platform: \"windows\"     arch: \"x64\"   timeout: 30                                  # Optional: timeout in seconds</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--configuration-fields","title":"Configuration Fields","text":"<p>api_url : str     API endpoint URL that returns JSON with version and download information.     This is a required field.</p> str <p>JSONPath expression to extract version from the API response. Examples: \"version\", \"release.version\", \"[0].version\" This is a required field.</p> str <p>JSONPath expression to extract download URL from the API response. Examples: \"download_url\", \"assets[0].url\", \"platforms.windows.x64\" This is a required field.</p> str, optional <p>HTTP method to use. Either \"GET\" or \"POST\". Default is \"GET\".</p> dict, optional <p>Custom HTTP headers to send with the request. Useful for authentication or setting Accept headers. Values support environment variable expansion. Example: {\"Authorization\": \"Bearer ${API_TOKEN}\"}</p> dict, optional <p>Request body for POST requests. Sent as JSON. Only used when method=\"POST\". Example: {\"platform\": \"windows\", \"arch\": \"x64\"}</p> int, optional <p>Request timeout in seconds. Default is 30.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--jsonpath-syntax","title":"JSONPath Syntax","text":"<p>Simple paths:   - \"version\" \u2192 {\"version\": \"1.2.3\"}   - \"release.version\" \u2192 {\"release\": {\"version\": \"1.2.3\"}}</p> Array indexing <ul> <li>\"[0].version\" \u2192 [{\"version\": \"1.2.3\"}]</li> <li>\"releases[-1].version\" \u2192 Last item in array</li> </ul> Nested paths <ul> <li>\"data.latest.download.url\"</li> <li>\"response.assets[0].browser_download_url\"</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--workflow-version-first","title":"Workflow (Version-First)","text":"<ol> <li>Build HTTP request (GET or POST) with headers</li> <li>Call API endpoint and get JSON response (~100ms)</li> <li>Parse JSON and extract version using JSONPath</li> <li>Extract download URL using JSONPath</li> <li>Create VersionInfo with version and download URL</li> <li>Core orchestration compares version to cache</li> <li>If match and file exists -&gt; skip download entirely</li> <li>If changed or missing -&gt; download from URL</li> </ol>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--error-handling","title":"Error Handling","text":"<ul> <li>ValueError: Missing or invalid configuration, invalid JSONPath, path not found</li> <li>RuntimeError: API failures, invalid JSON response</li> <li>Errors are chained with 'from err' for better debugging</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--example","title":"Example","text":"<p>In a recipe YAML (simple API):</p> <pre><code>apps:\n  - name: \"My App\"\n    id: \"my-app\"\n    source:\n      strategy: http_json\n      api_url: \"https://api.vendor.com/latest\"\n      version_path: \"version\"\n      download_url_path: \"download_url\"\n</code></pre> <p>In a recipe YAML (nested structure):</p> <pre><code>apps:\n  - name: \"My App\"\n    id: \"my-app\"\n    source:\n      strategy: http_json\n      api_url: \"https://api.vendor.com/releases\"\n      version_path: \"stable.version\"\n      download_url_path: \"stable.platforms.windows.x64\"\n      headers:\n        Authorization: \"Bearer ${API_TOKEN}\"\n</code></pre> <p>From Python (version-first approach):</p> <pre><code>from notapkgtool.discovery.http_json import HttpJsonStrategy\nfrom notapkgtool.io import download_file\n\nstrategy = HttpJsonStrategy()\napp_config = {\n    \"source\": {\n        \"api_url\": \"https://api.vendor.com/latest\",\n        \"version_path\": \"version\",\n        \"download_url_path\": \"download_url\",\n    }\n}\n\n# Get version WITHOUT downloading\nversion_info = strategy.get_version_info(app_config)\nprint(f\"Latest version: {version_info.version}\")\n\n# Download only if needed\nif need_to_download:\n    file_path, sha256, headers = download_file(\n        version_info.download_url, Path(\"./downloads\")\n    )\n    print(f\"Downloaded to {file_path}\")\n</code></pre> <p>From Python (using core orchestration):</p> <pre><code>from pathlib import Path\nfrom notapkgtool.core import discover_recipe\n\n# Automatically uses version-first optimization\nresult = discover_recipe(Path(\"recipe.yaml\"), Path(\"./downloads\"))\nprint(f\"Version {result['version']} at {result['file_path']}\")\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.http_json--notes","title":"Notes","text":"<ul> <li>Version discovery via API only (no download required)</li> <li>Core orchestration automatically skips download if version unchanged</li> <li>JSONPath uses jsonpath-ng library for robust parsing</li> <li>Environment variable expansion works in headers and other string values</li> <li>POST body is sent as JSON (Content-Type: application/json)</li> <li>Timeout defaults to 30 seconds to prevent hanging on slow APIs</li> </ul>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy","title":"<code>HttpJsonStrategy</code>","text":"<p>Discovery strategy for JSON API endpoints.</p> Configuration example <p>source:   strategy: http_json   api_url: \"https://api.vendor.com/latest\"   version_path: \"version\"   download_url_path: \"download_url\"   method: \"GET\"   headers:     Authorization: \"Bearer ${API_TOKEN}\"</p> Source code in <code>notapkgtool/discovery/http_json.py</code> <pre><code>class HttpJsonStrategy:\n    \"\"\"\n    Discovery strategy for JSON API endpoints.\n\n    Configuration example:\n        source:\n          strategy: http_json\n          api_url: \"https://api.vendor.com/latest\"\n          version_path: \"version\"\n          download_url_path: \"download_url\"\n          method: \"GET\"\n          headers:\n            Authorization: \"Bearer ${API_TOKEN}\"\n    \"\"\"\n\n    def get_version_info(\n        self,\n        app_config: dict[str, Any],\n        verbose: bool = False,\n        debug: bool = False,\n    ) -&gt; VersionInfo:\n        \"\"\"\n        Query JSON API for version and download URL without downloading (version-first path).\n\n        This method calls a JSON API, extracts version and download URL using\n        JSONPath expressions. If the version matches cached state, the download\n        can be skipped entirely.\n\n        Parameters\n        ----------\n        app_config : dict\n            App configuration containing source.api_url, source.version_path,\n            and source.download_url_path.\n        verbose : bool, optional\n            If True, print verbose logging messages. Default is False.\n        debug : bool, optional\n            If True, print debug logging messages. Default is False.\n\n        Returns\n        -------\n        VersionInfo\n            Version info with version string, download URL, and source name.\n\n        Raises\n        ------\n        ValueError\n            If required config fields are missing, invalid, or if JSONPath\n            expressions don't match anything in the response.\n        RuntimeError\n            If API call fails (chained with 'from err').\n\n        Examples\n        --------\n        &gt;&gt;&gt; strategy = HttpJsonStrategy()\n        &gt;&gt;&gt; config = {\n        ...     \"source\": {\n        ...         \"api_url\": \"https://api.vendor.com/latest\",\n        ...         \"version_path\": \"version\",\n        ...         \"download_url_path\": \"download_url\"\n        ...     }\n        ... }\n        &gt;&gt;&gt; version_info = strategy.get_version_info(config)\n        &gt;&gt;&gt; version_info.version\n        '1.0.0'\n        \"\"\"\n        from notapkgtool.cli import print_verbose\n\n        # Validate configuration\n        source = app_config.get(\"source\", {})\n        api_url = source.get(\"api_url\")\n        if not api_url:\n            raise ValueError(\"http_json strategy requires 'source.api_url' in config\")\n\n        version_path = source.get(\"version_path\")\n        if not version_path:\n            raise ValueError(\n                \"http_json strategy requires 'source.version_path' in config\"\n            )\n\n        download_url_path = source.get(\"download_url_path\")\n        if not download_url_path:\n            raise ValueError(\n                \"http_json strategy requires 'source.download_url_path' in config\"\n            )\n\n        # Optional configuration\n        method = source.get(\"method\", \"GET\").upper()\n        if method not in (\"GET\", \"POST\"):\n            raise ValueError(f\"Invalid method: {method!r}. Must be 'GET' or 'POST'\")\n\n        headers = source.get(\"headers\", {})\n        body = source.get(\"body\", {})\n        timeout = source.get(\"timeout\", 30)\n\n        print_verbose(\"DISCOVERY\", \"Strategy: http_json (version-first)\")\n        print_verbose(\"DISCOVERY\", f\"API URL: {api_url}\")\n        print_verbose(\"DISCOVERY\", f\"Method: {method}\")\n        print_verbose(\"DISCOVERY\", f\"Version path: {version_path}\")\n        print_verbose(\"DISCOVERY\", f\"Download URL path: {download_url_path}\")\n\n        # Expand environment variables in headers\n        expanded_headers = {}\n        for key, value in headers.items():\n            if (\n                isinstance(value, str)\n                and value.startswith(\"${\")\n                and value.endswith(\"}\")\n            ):\n                env_var = value[2:-1]\n                env_value = os.environ.get(env_var)\n                if not env_value:\n                    print_verbose(\n                        \"DISCOVERY\",\n                        f\"Warning: Environment variable {env_var} not set\",\n                    )\n                else:\n                    expanded_headers[key] = env_value\n            else:\n                expanded_headers[key] = value\n\n        # Make API request\n        print_verbose(\"DISCOVERY\", f\"Calling API: {method} {api_url}\")\n        try:\n            if method == \"GET\":\n                response = requests.get(\n                    api_url, headers=expanded_headers, timeout=timeout\n                )\n            else:  # POST\n                response = requests.post(\n                    api_url,\n                    headers=expanded_headers,\n                    json=body,\n                    timeout=timeout,\n                )\n            response.raise_for_status()\n        except requests.exceptions.HTTPError as err:\n            raise RuntimeError(\n                f\"API request failed: {response.status_code} {response.reason}\"\n            ) from err\n        except requests.exceptions.RequestException as err:\n            raise RuntimeError(f\"Failed to call API: {err}\") from err\n\n        print_verbose(\"DISCOVERY\", f\"API response: {response.status_code} OK\")\n\n        # Parse JSON response\n        try:\n            json_data = response.json()\n        except json.JSONDecodeError as err:\n            raise RuntimeError(\n                f\"Invalid JSON response from API. Response: {response.text[:200]}\"\n            ) from err\n\n        if debug:\n            print_verbose(\n                \"DISCOVERY\", f\"JSON response: {json.dumps(json_data, indent=2)}\"\n            )\n\n        # Extract version using JSONPath\n        print_verbose(\"DISCOVERY\", f\"Extracting version from path: {version_path}\")\n        try:\n            version_expr = jsonpath_parse(version_path)\n            version_matches = version_expr.find(json_data)\n\n            if not version_matches:\n                raise ValueError(\n                    f\"Version path {version_path!r} did not match anything in API response\"\n                )\n\n            version_str = str(version_matches[0].value)\n        except Exception as err:\n            if isinstance(err, ValueError):\n                raise\n            raise ValueError(\n                f\"Failed to extract version using path {version_path!r}: {err}\"\n            ) from err\n\n        print_verbose(\"DISCOVERY\", f\"Extracted version: {version_str}\")\n\n        # Extract download URL using JSONPath\n        print_verbose(\n            \"DISCOVERY\", f\"Extracting download URL from path: {download_url_path}\"\n        )\n        try:\n            url_expr = jsonpath_parse(download_url_path)\n            url_matches = url_expr.find(json_data)\n\n            if not url_matches:\n                raise ValueError(\n                    f\"Download URL path {download_url_path!r} did not match anything in API response\"\n                )\n\n            download_url = str(url_matches[0].value)\n        except Exception as err:\n            if isinstance(err, ValueError):\n                raise\n            raise ValueError(\n                f\"Failed to extract download URL using path {download_url_path!r}: {err}\"\n            ) from err\n\n        print_verbose(\"DISCOVERY\", f\"Download URL: {download_url}\")\n\n        return VersionInfo(\n            version=version_str,\n            download_url=download_url,\n            source=\"http_json\",\n        )\n\n    def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n        \"\"\"\n        Validate http_json strategy configuration.\n\n        Checks for required fields and correct types without making network calls.\n\n        Parameters\n        ----------\n        app_config : dict\n            The app configuration from the recipe.\n\n        Returns\n        -------\n        list[str]\n            List of error messages (empty if valid).\n        \"\"\"\n        errors = []\n        source = app_config.get(\"source\", {})\n\n        # Check required fields\n        if \"api_url\" not in source:\n            errors.append(\"Missing required field: source.api_url\")\n        elif not isinstance(source[\"api_url\"], str):\n            errors.append(\"source.api_url must be a string\")\n        elif not source[\"api_url\"].strip():\n            errors.append(\"source.api_url cannot be empty\")\n\n        if \"version_path\" not in source:\n            errors.append(\"Missing required field: source.version_path\")\n        elif not isinstance(source[\"version_path\"], str):\n            errors.append(\"source.version_path must be a string\")\n        elif not source[\"version_path\"].strip():\n            errors.append(\"source.version_path cannot be empty\")\n        else:\n            # Validate JSONPath syntax\n            from jsonpath_ng import parse as jsonpath_parse\n\n            try:\n                jsonpath_parse(source[\"version_path\"])\n            except Exception as err:\n                errors.append(f\"Invalid version_path JSONPath: {err}\")\n\n        if \"download_url_path\" not in source:\n            errors.append(\"Missing required field: source.download_url_path\")\n        elif not isinstance(source[\"download_url_path\"], str):\n            errors.append(\"source.download_url_path must be a string\")\n        elif not source[\"download_url_path\"].strip():\n            errors.append(\"source.download_url_path cannot be empty\")\n        else:\n            # Validate JSONPath syntax\n            from jsonpath_ng import parse as jsonpath_parse\n\n            try:\n                jsonpath_parse(source[\"download_url_path\"])\n            except Exception as err:\n                errors.append(f\"Invalid download_url_path JSONPath: {err}\")\n\n        # Optional fields validation\n        if \"method\" in source:\n            method = source[\"method\"]\n            if not isinstance(method, str):\n                errors.append(\"source.method must be a string\")\n            elif method.upper() not in [\"GET\", \"POST\"]:\n                errors.append(\"source.method must be 'GET' or 'POST'\")\n\n        if \"headers\" in source and not isinstance(source[\"headers\"], dict):\n            errors.append(\"source.headers must be a dictionary\")\n\n        if \"body\" in source and not isinstance(source[\"body\"], dict):\n            errors.append(\"source.body must be a dictionary\")\n\n        return errors\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.get_version_info","title":"<code>get_version_info(app_config, verbose=False, debug=False)</code>","text":"<p>Query JSON API for version and download URL without downloading (version-first path).</p> <p>This method calls a JSON API, extracts version and download URL using JSONPath expressions. If the version matches cached state, the download can be skipped entirely.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.get_version_info--parameters","title":"Parameters","text":"<p>app_config : dict     App configuration containing source.api_url, source.version_path,     and source.download_url_path. verbose : bool, optional     If True, print verbose logging messages. Default is False. debug : bool, optional     If True, print debug logging messages. Default is False.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.get_version_info--returns","title":"Returns","text":"<p>VersionInfo     Version info with version string, download URL, and source name.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.get_version_info--raises","title":"Raises","text":"<p>ValueError     If required config fields are missing, invalid, or if JSONPath     expressions don't match anything in the response. RuntimeError     If API call fails (chained with 'from err').</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.get_version_info--examples","title":"Examples","text":"<p>strategy = HttpJsonStrategy() config = { ...     \"source\": { ...         \"api_url\": \"https://api.vendor.com/latest\", ...         \"version_path\": \"version\", ...         \"download_url_path\": \"download_url\" ...     } ... } version_info = strategy.get_version_info(config) version_info.version '1.0.0'</p> Source code in <code>notapkgtool/discovery/http_json.py</code> <pre><code>def get_version_info(\n    self,\n    app_config: dict[str, Any],\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; VersionInfo:\n    \"\"\"\n    Query JSON API for version and download URL without downloading (version-first path).\n\n    This method calls a JSON API, extracts version and download URL using\n    JSONPath expressions. If the version matches cached state, the download\n    can be skipped entirely.\n\n    Parameters\n    ----------\n    app_config : dict\n        App configuration containing source.api_url, source.version_path,\n        and source.download_url_path.\n    verbose : bool, optional\n        If True, print verbose logging messages. Default is False.\n    debug : bool, optional\n        If True, print debug logging messages. Default is False.\n\n    Returns\n    -------\n    VersionInfo\n        Version info with version string, download URL, and source name.\n\n    Raises\n    ------\n    ValueError\n        If required config fields are missing, invalid, or if JSONPath\n        expressions don't match anything in the response.\n    RuntimeError\n        If API call fails (chained with 'from err').\n\n    Examples\n    --------\n    &gt;&gt;&gt; strategy = HttpJsonStrategy()\n    &gt;&gt;&gt; config = {\n    ...     \"source\": {\n    ...         \"api_url\": \"https://api.vendor.com/latest\",\n    ...         \"version_path\": \"version\",\n    ...         \"download_url_path\": \"download_url\"\n    ...     }\n    ... }\n    &gt;&gt;&gt; version_info = strategy.get_version_info(config)\n    &gt;&gt;&gt; version_info.version\n    '1.0.0'\n    \"\"\"\n    from notapkgtool.cli import print_verbose\n\n    # Validate configuration\n    source = app_config.get(\"source\", {})\n    api_url = source.get(\"api_url\")\n    if not api_url:\n        raise ValueError(\"http_json strategy requires 'source.api_url' in config\")\n\n    version_path = source.get(\"version_path\")\n    if not version_path:\n        raise ValueError(\n            \"http_json strategy requires 'source.version_path' in config\"\n        )\n\n    download_url_path = source.get(\"download_url_path\")\n    if not download_url_path:\n        raise ValueError(\n            \"http_json strategy requires 'source.download_url_path' in config\"\n        )\n\n    # Optional configuration\n    method = source.get(\"method\", \"GET\").upper()\n    if method not in (\"GET\", \"POST\"):\n        raise ValueError(f\"Invalid method: {method!r}. Must be 'GET' or 'POST'\")\n\n    headers = source.get(\"headers\", {})\n    body = source.get(\"body\", {})\n    timeout = source.get(\"timeout\", 30)\n\n    print_verbose(\"DISCOVERY\", \"Strategy: http_json (version-first)\")\n    print_verbose(\"DISCOVERY\", f\"API URL: {api_url}\")\n    print_verbose(\"DISCOVERY\", f\"Method: {method}\")\n    print_verbose(\"DISCOVERY\", f\"Version path: {version_path}\")\n    print_verbose(\"DISCOVERY\", f\"Download URL path: {download_url_path}\")\n\n    # Expand environment variables in headers\n    expanded_headers = {}\n    for key, value in headers.items():\n        if (\n            isinstance(value, str)\n            and value.startswith(\"${\")\n            and value.endswith(\"}\")\n        ):\n            env_var = value[2:-1]\n            env_value = os.environ.get(env_var)\n            if not env_value:\n                print_verbose(\n                    \"DISCOVERY\",\n                    f\"Warning: Environment variable {env_var} not set\",\n                )\n            else:\n                expanded_headers[key] = env_value\n        else:\n            expanded_headers[key] = value\n\n    # Make API request\n    print_verbose(\"DISCOVERY\", f\"Calling API: {method} {api_url}\")\n    try:\n        if method == \"GET\":\n            response = requests.get(\n                api_url, headers=expanded_headers, timeout=timeout\n            )\n        else:  # POST\n            response = requests.post(\n                api_url,\n                headers=expanded_headers,\n                json=body,\n                timeout=timeout,\n            )\n        response.raise_for_status()\n    except requests.exceptions.HTTPError as err:\n        raise RuntimeError(\n            f\"API request failed: {response.status_code} {response.reason}\"\n        ) from err\n    except requests.exceptions.RequestException as err:\n        raise RuntimeError(f\"Failed to call API: {err}\") from err\n\n    print_verbose(\"DISCOVERY\", f\"API response: {response.status_code} OK\")\n\n    # Parse JSON response\n    try:\n        json_data = response.json()\n    except json.JSONDecodeError as err:\n        raise RuntimeError(\n            f\"Invalid JSON response from API. Response: {response.text[:200]}\"\n        ) from err\n\n    if debug:\n        print_verbose(\n            \"DISCOVERY\", f\"JSON response: {json.dumps(json_data, indent=2)}\"\n        )\n\n    # Extract version using JSONPath\n    print_verbose(\"DISCOVERY\", f\"Extracting version from path: {version_path}\")\n    try:\n        version_expr = jsonpath_parse(version_path)\n        version_matches = version_expr.find(json_data)\n\n        if not version_matches:\n            raise ValueError(\n                f\"Version path {version_path!r} did not match anything in API response\"\n            )\n\n        version_str = str(version_matches[0].value)\n    except Exception as err:\n        if isinstance(err, ValueError):\n            raise\n        raise ValueError(\n            f\"Failed to extract version using path {version_path!r}: {err}\"\n        ) from err\n\n    print_verbose(\"DISCOVERY\", f\"Extracted version: {version_str}\")\n\n    # Extract download URL using JSONPath\n    print_verbose(\n        \"DISCOVERY\", f\"Extracting download URL from path: {download_url_path}\"\n    )\n    try:\n        url_expr = jsonpath_parse(download_url_path)\n        url_matches = url_expr.find(json_data)\n\n        if not url_matches:\n            raise ValueError(\n                f\"Download URL path {download_url_path!r} did not match anything in API response\"\n            )\n\n        download_url = str(url_matches[0].value)\n    except Exception as err:\n        if isinstance(err, ValueError):\n            raise\n        raise ValueError(\n            f\"Failed to extract download URL using path {download_url_path!r}: {err}\"\n        ) from err\n\n    print_verbose(\"DISCOVERY\", f\"Download URL: {download_url}\")\n\n    return VersionInfo(\n        version=version_str,\n        download_url=download_url,\n        source=\"http_json\",\n    )\n</code></pre>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.validate_config","title":"<code>validate_config(app_config)</code>","text":"<p>Validate http_json strategy configuration.</p> <p>Checks for required fields and correct types without making network calls.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.validate_config--parameters","title":"Parameters","text":"<p>app_config : dict     The app configuration from the recipe.</p>"},{"location":"api/discovery/#notapkgtool.discovery.http_json.HttpJsonStrategy.validate_config--returns","title":"Returns","text":"<p>list[str]     List of error messages (empty if valid).</p> Source code in <code>notapkgtool/discovery/http_json.py</code> <pre><code>def validate_config(self, app_config: dict[str, Any]) -&gt; list[str]:\n    \"\"\"\n    Validate http_json strategy configuration.\n\n    Checks for required fields and correct types without making network calls.\n\n    Parameters\n    ----------\n    app_config : dict\n        The app configuration from the recipe.\n\n    Returns\n    -------\n    list[str]\n        List of error messages (empty if valid).\n    \"\"\"\n    errors = []\n    source = app_config.get(\"source\", {})\n\n    # Check required fields\n    if \"api_url\" not in source:\n        errors.append(\"Missing required field: source.api_url\")\n    elif not isinstance(source[\"api_url\"], str):\n        errors.append(\"source.api_url must be a string\")\n    elif not source[\"api_url\"].strip():\n        errors.append(\"source.api_url cannot be empty\")\n\n    if \"version_path\" not in source:\n        errors.append(\"Missing required field: source.version_path\")\n    elif not isinstance(source[\"version_path\"], str):\n        errors.append(\"source.version_path must be a string\")\n    elif not source[\"version_path\"].strip():\n        errors.append(\"source.version_path cannot be empty\")\n    else:\n        # Validate JSONPath syntax\n        from jsonpath_ng import parse as jsonpath_parse\n\n        try:\n            jsonpath_parse(source[\"version_path\"])\n        except Exception as err:\n            errors.append(f\"Invalid version_path JSONPath: {err}\")\n\n    if \"download_url_path\" not in source:\n        errors.append(\"Missing required field: source.download_url_path\")\n    elif not isinstance(source[\"download_url_path\"], str):\n        errors.append(\"source.download_url_path must be a string\")\n    elif not source[\"download_url_path\"].strip():\n        errors.append(\"source.download_url_path cannot be empty\")\n    else:\n        # Validate JSONPath syntax\n        from jsonpath_ng import parse as jsonpath_parse\n\n        try:\n            jsonpath_parse(source[\"download_url_path\"])\n        except Exception as err:\n            errors.append(f\"Invalid download_url_path JSONPath: {err}\")\n\n    # Optional fields validation\n    if \"method\" in source:\n        method = source[\"method\"]\n        if not isinstance(method, str):\n            errors.append(\"source.method must be a string\")\n        elif method.upper() not in [\"GET\", \"POST\"]:\n            errors.append(\"source.method must be 'GET' or 'POST'\")\n\n    if \"headers\" in source and not isinstance(source[\"headers\"], dict):\n        errors.append(\"source.headers must be a dictionary\")\n\n    if \"body\" in source and not isinstance(source[\"body\"], dict):\n        errors.append(\"source.body must be a dictionary\")\n\n    return errors\n</code></pre>"},{"location":"api/io/","title":"I/O Module","text":"<p>The I/O module handles robust file downloads and uploads with retry logic, conditional requests, and atomic operations.</p>"},{"location":"api/io/#download","title":"Download","text":""},{"location":"api/io/#notapkgtool.io.download","title":"<code>notapkgtool.io.download</code>","text":"<p>Robust HTTP(S) file download for NAPT.</p> <p>This module provides production-grade file downloading with features designed for reliability, reproducibility, and efficiency in automated packaging workflows.</p>"},{"location":"api/io/#notapkgtool.io.download--key-features","title":"Key Features","text":"<ol> <li>Retry Logic with Exponential Backoff</li> <li>Automatically retries on transient failures (429, 500, 502, 503, 504)</li> <li>Exponential backoff prevents overwhelming failing servers</li> <li> <p>Configurable via urllib3.util.Retry</p> </li> <li> <p>Conditional Requests (HTTP 304 Not Modified)</p> </li> <li>Supports ETag and Last-Modified headers</li> <li>Avoids re-downloading unchanged files</li> <li> <p>Essential for incremental builds and bandwidth efficiency</p> </li> <li> <p>Atomic Writes</p> </li> <li>Downloads to temporary .part files</li> <li>Atomic rename on success prevents partial files</li> <li> <p>Safe for concurrent or interrupted operations</p> </li> <li> <p>Integrity Verification</p> </li> <li>SHA-256 hashing during download (no extra file read)</li> <li>Optional checksum validation</li> <li> <p>Corrupted files are automatically removed</p> </li> <li> <p>Smart Filename Detection</p> </li> <li>Respects Content-Disposition headers</li> <li>Falls back to URL path</li> <li> <p>Handles edge cases (empty paths, query strings)</p> </li> <li> <p>Stable ETags</p> </li> <li>Forces Accept-Encoding: identity to avoid representation-specific ETags</li> <li>Prevents false cache misses when CDN switches compression</li> </ol>"},{"location":"api/io/#notapkgtool.io.download--functions","title":"Functions","text":"<p>download_file : function     Main entry point for downloading files with all features. make_session : function     Create a requests.Session with sane retry/backoff defaults.</p>"},{"location":"api/io/#notapkgtool.io.download--exceptions","title":"Exceptions","text":"<p>NotModifiedError : exception     Raised when conditional request returns HTTP 304 (not an error condition).</p>"},{"location":"api/io/#notapkgtool.io.download--constants","title":"Constants","text":"<p>DEFAULT_CHUNK : int     Stream chunk size (1 MiB). Balance memory vs. progress granularity.</p>"},{"location":"api/io/#notapkgtool.io.download--examples","title":"Examples","text":"<p>Basic download:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from notapkgtool.io import download_file\n&gt;&gt;&gt; path, sha256, headers = download_file(\n...     url=\"https://example.com/installer.msi\",\n...     destination_folder=Path(\"./downloads\"),\n... )\n&gt;&gt;&gt; print(f\"Downloaded to {path}\")\n&gt;&gt;&gt; print(f\"SHA-256: {sha256}\")\n</code></pre> <p>Conditional download (avoid re-downloading):</p> <pre><code>&gt;&gt;&gt; try:\n...     path, sha256, headers = download_file(\n...         url=\"https://example.com/installer.msi\",\n...         destination_folder=Path(\"./downloads\"),\n...         etag=previous_etag,\n...     )\n... except NotModifiedError:\n...     print(\"File unchanged, using cached version\")\n</code></pre> <p>Checksum validation:</p> <pre><code>&gt;&gt;&gt; try:\n...     path, sha256, headers = download_file(\n...         url=\"https://example.com/installer.msi\",\n...         destination_folder=Path(\"./downloads\"),\n...         expected_sha256=\"abc123...\",\n...     )\n... except ValueError as e:\n...     print(f\"Checksum mismatch: {e}\")\n</code></pre>"},{"location":"api/io/#notapkgtool.io.download--design-decisions","title":"Design Decisions","text":"<ul> <li> <p>Why identity encoding? CDNs like Cloudflare compute representation-specific   ETags. Requesting gzip vs identity yields different ETags for the same content,   causing unnecessary re-downloads. We pin to identity for stability.</p> </li> <li> <p>Why atomic writes? Prevents partial files from appearing in the destination.   Critical for automation where another process might start using a file before   download completes.</p> </li> <li> <p>Why stream hashing? Computing SHA-256 while streaming avoids a second   file read, improving I/O efficiency especially for large installers.</p> </li> </ul>"},{"location":"api/io/#notapkgtool.io.download--notes","title":"Notes","text":"<ul> <li>Progress output goes to stdout (can be captured/redirected)</li> <li>User-Agent identifies NAPT to help with debugging/support</li> <li>All HTTP errors are chained for better debugging</li> <li>Timeouts are per-request, not total download time</li> </ul>"},{"location":"api/io/#notapkgtool.io.download.NotModifiedError","title":"<code>NotModifiedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a conditional request (If-None-Match / If-Modified-Since) returns HTTP 304 Not Modified. Caller can treat this as \"no work to do\".</p> Source code in <code>notapkgtool/io/download.py</code> <pre><code>class NotModifiedError(Exception):\n    \"\"\"\n    Raised when a conditional request (If-None-Match / If-Modified-Since)\n    returns HTTP 304 Not Modified. Caller can treat this as \"no work to do\".\n    \"\"\"\n</code></pre>"},{"location":"api/io/#notapkgtool.io.download.make_session","title":"<code>make_session()</code>","text":"<p>Create a requests.Session with sane retry/backoff defaults.</p> <ul> <li>Retries on common transient status codes.</li> <li>Applies exponential backoff.</li> <li>Sets a helpful User-Agent to avoid being blocked.</li> </ul> <p>Notes on Accept-Encoding: - We force 'Accept-Encoding: identity' to request the raw (uncompressed) bytes. - Many CDNs compute representation-specific ETags (e.g., gzip vs identity).   That can cause conditional requests (If-None-Match) to miss and trigger   unnecessary re-downloads. Pinning identity stabilizes ETags for binary   installers (MSI/EXE/MSIX/ZIP), which are already compressed.</p> Source code in <code>notapkgtool/io/download.py</code> <pre><code>def make_session() -&gt; requests.Session:\n    \"\"\"\n    Create a requests.Session with sane retry/backoff defaults.\n\n    - Retries on common transient status codes.\n    - Applies exponential backoff.\n    - Sets a helpful User-Agent to avoid being blocked.\n\n    Notes on Accept-Encoding:\n    - We force 'Accept-Encoding: identity' to request the raw (uncompressed) bytes.\n    - Many CDNs compute representation-specific ETags (e.g., gzip vs identity).\n      That can cause conditional requests (If-None-Match) to miss and trigger\n      unnecessary re-downloads. Pinning identity stabilizes ETags for binary\n      installers (MSI/EXE/MSIX/ZIP), which are already compressed.\n    \"\"\"\n    s = requests.Session()\n    retries = Retry(\n        total=5,\n        backoff_factor=0.5,\n        status_forcelist=(429, 500, 502, 503, 504),\n        allowed_methods=(\"GET\", \"HEAD\"),\n        raise_on_status=False,\n    )\n    s.headers.update(\n        {\n            \"User-Agent\": \"napt/0.1 (+https://github.com/RogerCibrian/notapkgtool)\",\n            # Request the raw, uncompressed representation to keep ETags stable\n            # across runs and avoid spurious 200s when a CDN flips to gzip.\n            \"Accept-Encoding\": \"identity\",\n        }\n    )\n    s.mount(\"http://\", HTTPAdapter(max_retries=retries))\n    s.mount(\"https://\", HTTPAdapter(max_retries=retries))\n    return s\n</code></pre>"},{"location":"api/io/#notapkgtool.io.download.download_file","title":"<code>download_file(url, destination_folder, *, expected_sha256=None, validate_content_type=False, timeout=60, etag=None, last_modified=None, verbose=False, debug=False)</code>","text":"<p>Download a URL to destination_folder with robustness and reproducibility.</p> <p>Behavior - Follows redirects and retries transient failures. - If validate_content_type=True, rejects text/html (helps catch \"download page\" instead of a file). - Writes to .part then renames to  on success (atomic). - Returns (final_path, sha256, response_headers_dict). - If 'expected_sha256' is set, validates and raises on mismatch (removes corrupt file). - If 'etag' and/or 'last_modified' are given, sends conditional headers. A 304 causes NotModifiedError. <p>Parameters - url: Source URL. - destination_folder: Folder to save into (created if missing). - expected_sha256: Optional known SHA-256 (hex). If set and mismatched, raises ValueError. - validate_content_type: If True, rejects responses with text/html content-type. - timeout: Per-request timeout (seconds). - etag: Previous ETag to use for If-None-Match (conditional GET). - last_modified: Previous Last-Modified to use for If-Modified-Since (conditional GET).</p> <p>Returns - (Path, sha256_hex, headers_dict)</p> <p>Raises - NotModifiedError on HTTP 304 (conditional request satisfied). - requests.HTTPError for non-2xx (after retries). - ValueError for content-type mismatch or checksum mismatch.</p> Source code in <code>notapkgtool/io/download.py</code> <pre><code>def download_file(\n    url: str,\n    destination_folder: Path,\n    *,\n    expected_sha256: str | None = None,\n    validate_content_type: bool = False,\n    timeout: int = 60,\n    etag: str | None = None,\n    last_modified: str | None = None,\n    verbose: bool = False,\n    debug: bool = False,\n) -&gt; tuple[Path, str, dict]:\n    \"\"\"\n    Download a URL to destination_folder with robustness and reproducibility.\n\n    Behavior\n    - Follows redirects and retries transient failures.\n    - If validate_content_type=True, rejects text/html (helps catch \"download page\" instead of a file).\n    - Writes to &lt;filename&gt;.part then renames to &lt;filename&gt; on success (atomic).\n    - Returns (final_path, sha256, response_headers_dict).\n    - If 'expected_sha256' is set, validates and raises on mismatch (removes corrupt file).\n    - If 'etag' and/or 'last_modified' are given, sends conditional headers. A 304 causes NotModifiedError.\n\n    Parameters\n    - url: Source URL.\n    - destination_folder: Folder to save into (created if missing).\n    - expected_sha256: Optional known SHA-256 (hex). If set and mismatched, raises ValueError.\n    - validate_content_type: If True, rejects responses with text/html content-type.\n    - timeout: Per-request timeout (seconds).\n    - etag: Previous ETag to use for If-None-Match (conditional GET).\n    - last_modified: Previous Last-Modified to use for If-Modified-Since (conditional GET).\n\n    Returns\n    - (Path, sha256_hex, headers_dict)\n\n    Raises\n    - NotModifiedError on HTTP 304 (conditional request satisfied).\n    - requests.HTTPError for non-2xx (after retries).\n    - ValueError for content-type mismatch or checksum mismatch.\n    \"\"\"\n    from notapkgtool.cli import print_verbose\n\n    destination_folder = Path(destination_folder)\n    destination_folder.mkdir(parents=True, exist_ok=True)\n\n    headers: dict[str, str] = {}\n    if etag:\n        headers[\"If-None-Match\"] = etag\n        print_verbose(\"HTTP\", f\"Using conditional request with ETag: {etag}\")\n    elif last_modified:\n        headers[\"If-Modified-Since\"] = last_modified\n        print_verbose(\n            \"HTTP\", f\"Using conditional request with Last-Modified: {last_modified}\"\n        )\n\n    print_verbose(\"HTTP\", f\"GET {url}\")\n    if verbose:\n        print_verbose(\n            \"HTTP\",\n            \"Request headers: Accept-Encoding: identity, User-Agent: napt/0.1.0\",\n        )\n\n    with make_session() as session:\n        # Stream response so we can hash while writing.\n        resp = session.get(\n            url, stream=True, allow_redirects=True, timeout=timeout, headers=headers\n        )\n\n        # Log redirects\n        if verbose and len(resp.history) &gt; 0:\n            for hist in resp.history:\n                print_verbose(\n                    \"HTTP\",\n                    f\"Redirect {hist.status_code} -&gt; {hist.headers.get('Location', 'unknown')}\",\n                )\n\n        # Conditional request satisfied: nothing changed since last time.\n        if resp.status_code == 304:\n            print_verbose(\"HTTP\", \"Response: 304 Not Modified\")\n            resp.close()\n            raise NotModifiedError(\"Remote content not modified (HTTP 304).\")\n\n        # Raise for other HTTP errors after retries.\n        try:\n            resp.raise_for_status()\n        except requests.HTTPError as err:\n            # Chain for better context.\n            raise requests.HTTPError(f\"download failed for {url}: {err}\") from err\n\n        print_verbose(\"HTTP\", f\"Response: {resp.status_code} {resp.reason}\")\n\n        # Content-Disposition beats URL when naming the file.\n        cd_name = _filename_from_cd(resp.headers.get(\"Content-Disposition\", \"\"))\n        filename = cd_name or _filename_from_url(resp.url)\n        target = destination_folder / filename\n\n        # Log response details\n        if verbose:\n            content_length = resp.headers.get(\"Content-Length\", \"unknown\")\n            if content_length != \"unknown\":\n                size_mb = int(content_length) / (1024 * 1024)\n                print_verbose(\n                    \"HTTP\", f\"Content-Length: {content_length} ({size_mb:.1f} MB)\"\n                )\n            etag_value = resp.headers.get(\"ETag\", \"not provided\")\n            print_verbose(\"HTTP\", f\"ETag: {etag_value}\")\n            cd_header = resp.headers.get(\"Content-Disposition\", \"not provided\")\n            print_verbose(\"HTTP\", f\"Content-Disposition: {cd_header}\")\n\n        # Optional content-type sanity check.\n        if validate_content_type:\n            ctype = resp.headers.get(\"Content-Type\", \"\")\n            if \"text/html\" in ctype.lower():\n                resp.close()\n                raise ValueError(f\"expected binary, got content-type={ctype}\")\n\n        total_size = int(resp.headers.get(\"Content-Length\", \"0\") or 0)\n\n        tmp = target.with_suffix(target.suffix + \".part\")\n        print_verbose(\"FILE\", f\"Downloading to: {tmp}\")\n\n        sha = hashlib.sha256()\n        downloaded = 0\n        last_percent = -1\n        started_at = time.time()\n\n        with tmp.open(\"wb\") as f:\n            for chunk in resp.iter_content(chunk_size=DEFAULT_CHUNK):\n                if not chunk:\n                    continue\n                f.write(chunk)\n                sha.update(chunk)\n                downloaded += len(chunk)\n\n                # Optional lightweight progress indicator.\n                if total_size:\n                    pct = int(downloaded * 100 / total_size)\n                    if pct != last_percent:\n                        print(f\"download progress: {pct}%\", end=\"\\r\")\n                        last_percent = pct\n\n        # Cleanup response socket.\n        resp.close()\n\n        digest = sha.hexdigest()\n        print_verbose(\"FILE\", f\"SHA-256: {digest} (computed during download)\")\n\n        # Atomically \"commit\" the file.\n        print_verbose(\"FILE\", f\"Atomic rename: {tmp.name} -&gt; {target.name}\")\n        tmp.replace(target)\n\n        # Validate checksum if the caller expects a specific digest.\n        if expected_sha256 and digest.lower() != expected_sha256.lower():\n            print_verbose(\n                \"FILE\", f\"Checksum mismatch! Expected: {expected_sha256}, Got: {digest}\"\n            )\n            try:\n                target.unlink()\n            except OSError:\n                pass\n            raise ValueError(\n                f\"sha256 mismatch for {filename}: got {digest}, expected {expected_sha256}\"\n            )\n\n        elapsed = time.time() - started_at\n        if not verbose:\n            # For non-verbose mode, just show simple completion message\n            print(f\"\\ndownload complete: {target} ({digest}) in {elapsed:.1f}s\")\n        else:\n            # For verbose mode, show detailed file info\n            print_verbose(\"FILE\", f\"Download complete: {target}\")\n            print_verbose(\"FILE\", f\"Time elapsed: {elapsed:.1f}s\")\n\n        # Hand back headers the caller may want to persist (ETag, Last-Modified).\n        return target, digest, dict(resp.headers)\n</code></pre>"},{"location":"api/io/#upload","title":"Upload","text":""},{"location":"api/io/#notapkgtool.io.upload","title":"<code>notapkgtool.io.upload</code>","text":""},{"location":"api/state/","title":"State Module","text":"<p>The state module provides version tracking and ETag caching for efficient conditional downloads.</p>"},{"location":"api/state/#notapkgtool.state","title":"<code>notapkgtool.state</code>","text":"<p>State tracking and version management for NAPT.</p> <p>This module provides state persistence for tracking discovered application versions, ETags, and file metadata between runs. This enables: - Efficient conditional downloads (HTTP 304 Not Modified) - Version change detection - Bandwidth optimization for scheduled workflows</p> <p>The state file is a JSON file that stores: - Discovered versions from vendors - HTTP ETags and Last-Modified headers for conditional requests - File paths and SHA-256 hashes for cached installers - Last checked timestamps for monitoring</p> <p>State tracking is enabled by default and can be disabled with --stateless flag.</p>"},{"location":"api/state/#notapkgtool.state--public-api","title":"Public API","text":"<p>StateTracker : class     Main interface for state management operations. load_state : function     Load state from JSON file. save_state : function     Save state to JSON file with pretty-printing.</p>"},{"location":"api/state/#notapkgtool.state--example","title":"Example","text":"<p>Basic usage:</p> <pre><code>from pathlib import Path\nfrom notapkgtool.state import load_state, save_state\n\n# Load state\nstate = load_state(Path(\"state/versions.json\"))\n\n# Get cache for a recipe\ncache = state.get(\"apps\", {}).get(\"napt-chrome\")\n\n# Update cache\nstate[\"apps\"][\"napt-chrome\"] = {\n    \"url\": \"https://dl.google.com/chrome.msi\",\n    \"etag\": \"W/\"abc123\"\",\n    \"sha256\": \"abc123...\",\n    \"known_version\": \"130.0.0\"\n}\n\n# Save state\nsave_state(state, Path(\"state/versions.json\"))\n</code></pre>"},{"location":"api/state/#notapkgtool.state.StateTracker","title":"<code>StateTracker</code>","text":"<p>Manages application state tracking with automatic persistence.</p> <p>This class provides a high-level interface for loading, querying, and updating the state file. It handles file I/O, error recovery, and provides convenience methods for common operations.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker--attributes","title":"Attributes","text":"<p>state_file : Path     Path to the JSON state file. state : dict     In-memory state dictionary.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker--examples","title":"Examples","text":"<p>Basic usage:</p> <pre><code>&gt;&gt;&gt; tracker = StateTracker(Path(\"state/versions.json\"))\n&gt;&gt;&gt; tracker.load()\n</code></pre> <p>cache = tracker.get_cache(\"napt-chrome\") tracker.update_cache(\"napt-chrome\", ...     url=\"https://...\", sha256=\"...\", known_version=\"130.0.0\") tracker.save()</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>class StateTracker:\n    \"\"\"\n    Manages application state tracking with automatic persistence.\n\n    This class provides a high-level interface for loading, querying, and\n    updating the state file. It handles file I/O, error recovery, and\n    provides convenience methods for common operations.\n\n    Attributes\n    ----------\n    state_file : Path\n        Path to the JSON state file.\n    state : dict\n        In-memory state dictionary.\n\n    Examples\n    --------\n    Basic usage:\n\n        &gt;&gt;&gt; tracker = StateTracker(Path(\"state/versions.json\"))\n        &gt;&gt;&gt; tracker.load()\n    &gt;&gt;&gt; cache = tracker.get_cache(\"napt-chrome\")\n    &gt;&gt;&gt; tracker.update_cache(\"napt-chrome\",\n    ...     url=\"https://...\", sha256=\"...\", known_version=\"130.0.0\")\n    &gt;&gt;&gt; tracker.save()\n    \"\"\"\n\n    def __init__(self, state_file: Path):\n        \"\"\"\n        Initialize state tracker.\n\n        Parameters\n        ----------\n        state_file : Path\n            Path to JSON state file. Created if doesn't exist.\n        \"\"\"\n        self.state_file = state_file\n        self.state: dict[str, Any] = {}\n\n    def load(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Load state from file.\n\n        Creates default state structure if file doesn't exist.\n        Handles corrupted files by creating backup and starting fresh.\n\n        Returns\n        -------\n        dict\n            Loaded state dictionary.\n\n        Raises\n        ------\n        OSError\n            If file permissions prevent reading.\n        \"\"\"\n        try:\n            self.state = load_state(self.state_file)\n        except FileNotFoundError:\n            # First run, create default state\n            self.state = create_default_state()\n            self.state_file.parent.mkdir(parents=True, exist_ok=True)\n            self.save()\n        except json.JSONDecodeError as err:\n            # Corrupted file, backup and create new\n            backup = self.state_file.with_suffix(\".json.backup\")\n            self.state_file.rename(backup)\n            self.state = create_default_state()\n            self.save()\n            raise RuntimeError(\n                f\"Corrupted state file backed up to {backup}. \"\n                f\"Created fresh state file.\"\n            ) from err\n\n        return self.state\n\n    def save(self) -&gt; None:\n        \"\"\"\n        Save current state to file.\n\n        Updates metadata.last_updated timestamp automatically.\n        Creates parent directories if needed.\n\n        Raises\n        ------\n        OSError\n            If file permissions prevent writing.\n        \"\"\"\n        # Update metadata\n        self.state.setdefault(\"metadata\", {})\n        self.state[\"metadata\"][\"last_updated\"] = datetime.now(UTC).isoformat()\n\n        # Ensure parent directory exists\n        self.state_file.parent.mkdir(parents=True, exist_ok=True)\n\n        save_state(self.state, self.state_file)\n\n    def get_cache(self, recipe_id: str) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Get cached information for a recipe.\n\n        Parameters\n        ----------\n        recipe_id : str\n            Recipe identifier (from recipe's 'id' field).\n\n        Returns\n        -------\n        dict or None\n            Cached data if available, None otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; cache = tracker.get_cache(\"napt-chrome\")\n        &gt;&gt;&gt; if cache:\n        ...     etag = cache.get('etag')\n        ...     known_version = cache.get('known_version')\n        \"\"\"\n        return self.state.get(\"apps\", {}).get(recipe_id)\n\n    def update_cache(\n        self,\n        recipe_id: str,\n        url: str,\n        sha256: str,\n        etag: str | None = None,\n        last_modified: str | None = None,\n        known_version: str | None = None,\n        strategy: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Update cached information for a recipe.\n\n        Parameters\n        ----------\n        recipe_id : str\n            Recipe identifier.\n        url : str\n            Download URL for provenance tracking. For version-first strategies\n            (url_regex, github_release, http_json), this is the actual download URL\n            from version_info. For file-first (http_static), this is source.url.\n        sha256 : str\n            SHA-256 hash of file (for integrity checks).\n        etag : str, optional\n            ETag header from download response. Used by http_static for HTTP 304\n            conditional requests. Saved but unused by version-first strategies.\n        last_modified : str, optional\n            Last-Modified header from download response. Used by http_static as\n            fallback for conditional requests. Saved but unused by version-first.\n        known_version : str, optional\n            Version string. PRIMARY cache key for version-first strategies\n            (compared to skip downloads). Informational only for http_static.\n        strategy : str, optional\n            Discovery strategy used (for debugging).\n\n        Examples\n        --------\n        &gt;&gt;&gt; tracker.update_cache(\n        ...     \"napt-chrome\",\n        ...     url=\"https://dl.google.com/chrome.msi\",\n        ...     sha256=\"abc123...\",\n        ...     etag='W/\"def456\"',\n        ...     known_version=\"130.0.0\"\n        ... )\n\n        Notes\n        -----\n        Schema v2: Removed file_path, last_checked, and renamed version\u2192known_version.\n\n        Field usage differs by strategy type:\n        - Version-first: known_version is PRIMARY cache key, etag/last_modified unused\n        - File-first: etag/last_modified are PRIMARY cache keys, known_version informational\n\n        Filesystem is the source of truth; state is for optimization only.\n        \"\"\"\n        if \"apps\" not in self.state:\n            self.state[\"apps\"] = {}\n\n        cache_entry = {\n            \"url\": url,\n            \"etag\": etag,\n            \"last_modified\": last_modified,\n            \"sha256\": sha256,\n        }\n\n        # Optional fields (only add if provided)\n        if known_version is not None:\n            cache_entry[\"known_version\"] = known_version\n        if strategy is not None:\n            cache_entry[\"strategy\"] = strategy\n\n        self.state[\"apps\"][recipe_id] = cache_entry\n\n    def has_version_changed(self, recipe_id: str, new_version: str) -&gt; bool:\n        \"\"\"\n        Check if discovered version differs from cached known_version.\n\n        Parameters\n        ----------\n        recipe_id : str\n            Recipe identifier.\n        new_version : str\n            Newly discovered version.\n\n        Returns\n        -------\n        bool\n            True if version changed or no cached version exists.\n\n        Examples\n        --------\n        &gt;&gt;&gt; if tracker.has_version_changed(\"napt-chrome\", \"130.0.0\"):\n        ...     print(\"New version available!\")\n\n        Notes\n        -----\n        Uses 'known_version' field which is informational only.\n        Real version should be extracted from filesystem during build.\n        \"\"\"\n        cache = self.get_cache(recipe_id)\n        if not cache:\n            return True  # No cache, treat as changed\n\n        return cache.get(\"known_version\") != new_version\n</code></pre>"},{"location":"api/state/#notapkgtool.state.StateTracker.__init__","title":"<code>__init__(state_file)</code>","text":"<p>Initialize state tracker.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.__init__--parameters","title":"Parameters","text":"<p>state_file : Path     Path to JSON state file. Created if doesn't exist.</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def __init__(self, state_file: Path):\n    \"\"\"\n    Initialize state tracker.\n\n    Parameters\n    ----------\n    state_file : Path\n        Path to JSON state file. Created if doesn't exist.\n    \"\"\"\n    self.state_file = state_file\n    self.state: dict[str, Any] = {}\n</code></pre>"},{"location":"api/state/#notapkgtool.state.StateTracker.load","title":"<code>load()</code>","text":"<p>Load state from file.</p> <p>Creates default state structure if file doesn't exist. Handles corrupted files by creating backup and starting fresh.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.load--returns","title":"Returns","text":"<p>dict     Loaded state dictionary.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.load--raises","title":"Raises","text":"<p>OSError     If file permissions prevent reading.</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def load(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Load state from file.\n\n    Creates default state structure if file doesn't exist.\n    Handles corrupted files by creating backup and starting fresh.\n\n    Returns\n    -------\n    dict\n        Loaded state dictionary.\n\n    Raises\n    ------\n    OSError\n        If file permissions prevent reading.\n    \"\"\"\n    try:\n        self.state = load_state(self.state_file)\n    except FileNotFoundError:\n        # First run, create default state\n        self.state = create_default_state()\n        self.state_file.parent.mkdir(parents=True, exist_ok=True)\n        self.save()\n    except json.JSONDecodeError as err:\n        # Corrupted file, backup and create new\n        backup = self.state_file.with_suffix(\".json.backup\")\n        self.state_file.rename(backup)\n        self.state = create_default_state()\n        self.save()\n        raise RuntimeError(\n            f\"Corrupted state file backed up to {backup}. \"\n            f\"Created fresh state file.\"\n        ) from err\n\n    return self.state\n</code></pre>"},{"location":"api/state/#notapkgtool.state.StateTracker.save","title":"<code>save()</code>","text":"<p>Save current state to file.</p> <p>Updates metadata.last_updated timestamp automatically. Creates parent directories if needed.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.save--raises","title":"Raises","text":"<p>OSError     If file permissions prevent writing.</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"\n    Save current state to file.\n\n    Updates metadata.last_updated timestamp automatically.\n    Creates parent directories if needed.\n\n    Raises\n    ------\n    OSError\n        If file permissions prevent writing.\n    \"\"\"\n    # Update metadata\n    self.state.setdefault(\"metadata\", {})\n    self.state[\"metadata\"][\"last_updated\"] = datetime.now(UTC).isoformat()\n\n    # Ensure parent directory exists\n    self.state_file.parent.mkdir(parents=True, exist_ok=True)\n\n    save_state(self.state, self.state_file)\n</code></pre>"},{"location":"api/state/#notapkgtool.state.StateTracker.get_cache","title":"<code>get_cache(recipe_id)</code>","text":"<p>Get cached information for a recipe.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.get_cache--parameters","title":"Parameters","text":"<p>recipe_id : str     Recipe identifier (from recipe's 'id' field).</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.get_cache--returns","title":"Returns","text":"<p>dict or None     Cached data if available, None otherwise.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.get_cache--examples","title":"Examples","text":"<p>cache = tracker.get_cache(\"napt-chrome\") if cache: ...     etag = cache.get('etag') ...     known_version = cache.get('known_version')</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def get_cache(self, recipe_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get cached information for a recipe.\n\n    Parameters\n    ----------\n    recipe_id : str\n        Recipe identifier (from recipe's 'id' field).\n\n    Returns\n    -------\n    dict or None\n        Cached data if available, None otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; cache = tracker.get_cache(\"napt-chrome\")\n    &gt;&gt;&gt; if cache:\n    ...     etag = cache.get('etag')\n    ...     known_version = cache.get('known_version')\n    \"\"\"\n    return self.state.get(\"apps\", {}).get(recipe_id)\n</code></pre>"},{"location":"api/state/#notapkgtool.state.StateTracker.update_cache","title":"<code>update_cache(recipe_id, url, sha256, etag=None, last_modified=None, known_version=None, strategy=None)</code>","text":"<p>Update cached information for a recipe.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.update_cache--parameters","title":"Parameters","text":"<p>recipe_id : str     Recipe identifier. url : str     Download URL for provenance tracking. For version-first strategies     (url_regex, github_release, http_json), this is the actual download URL     from version_info. For file-first (http_static), this is source.url. sha256 : str     SHA-256 hash of file (for integrity checks). etag : str, optional     ETag header from download response. Used by http_static for HTTP 304     conditional requests. Saved but unused by version-first strategies. last_modified : str, optional     Last-Modified header from download response. Used by http_static as     fallback for conditional requests. Saved but unused by version-first. known_version : str, optional     Version string. PRIMARY cache key for version-first strategies     (compared to skip downloads). Informational only for http_static. strategy : str, optional     Discovery strategy used (for debugging).</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.update_cache--examples","title":"Examples","text":"<p>tracker.update_cache( ...     \"napt-chrome\", ...     url=\"https://dl.google.com/chrome.msi\", ...     sha256=\"abc123...\", ...     etag='W/\"def456\"', ...     known_version=\"130.0.0\" ... )</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.update_cache--notes","title":"Notes","text":"<p>Schema v2: Removed file_path, last_checked, and renamed version\u2192known_version.</p> <p>Field usage differs by strategy type: - Version-first: known_version is PRIMARY cache key, etag/last_modified unused - File-first: etag/last_modified are PRIMARY cache keys, known_version informational</p> <p>Filesystem is the source of truth; state is for optimization only.</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def update_cache(\n    self,\n    recipe_id: str,\n    url: str,\n    sha256: str,\n    etag: str | None = None,\n    last_modified: str | None = None,\n    known_version: str | None = None,\n    strategy: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Update cached information for a recipe.\n\n    Parameters\n    ----------\n    recipe_id : str\n        Recipe identifier.\n    url : str\n        Download URL for provenance tracking. For version-first strategies\n        (url_regex, github_release, http_json), this is the actual download URL\n        from version_info. For file-first (http_static), this is source.url.\n    sha256 : str\n        SHA-256 hash of file (for integrity checks).\n    etag : str, optional\n        ETag header from download response. Used by http_static for HTTP 304\n        conditional requests. Saved but unused by version-first strategies.\n    last_modified : str, optional\n        Last-Modified header from download response. Used by http_static as\n        fallback for conditional requests. Saved but unused by version-first.\n    known_version : str, optional\n        Version string. PRIMARY cache key for version-first strategies\n        (compared to skip downloads). Informational only for http_static.\n    strategy : str, optional\n        Discovery strategy used (for debugging).\n\n    Examples\n    --------\n    &gt;&gt;&gt; tracker.update_cache(\n    ...     \"napt-chrome\",\n    ...     url=\"https://dl.google.com/chrome.msi\",\n    ...     sha256=\"abc123...\",\n    ...     etag='W/\"def456\"',\n    ...     known_version=\"130.0.0\"\n    ... )\n\n    Notes\n    -----\n    Schema v2: Removed file_path, last_checked, and renamed version\u2192known_version.\n\n    Field usage differs by strategy type:\n    - Version-first: known_version is PRIMARY cache key, etag/last_modified unused\n    - File-first: etag/last_modified are PRIMARY cache keys, known_version informational\n\n    Filesystem is the source of truth; state is for optimization only.\n    \"\"\"\n    if \"apps\" not in self.state:\n        self.state[\"apps\"] = {}\n\n    cache_entry = {\n        \"url\": url,\n        \"etag\": etag,\n        \"last_modified\": last_modified,\n        \"sha256\": sha256,\n    }\n\n    # Optional fields (only add if provided)\n    if known_version is not None:\n        cache_entry[\"known_version\"] = known_version\n    if strategy is not None:\n        cache_entry[\"strategy\"] = strategy\n\n    self.state[\"apps\"][recipe_id] = cache_entry\n</code></pre>"},{"location":"api/state/#notapkgtool.state.StateTracker.has_version_changed","title":"<code>has_version_changed(recipe_id, new_version)</code>","text":"<p>Check if discovered version differs from cached known_version.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.has_version_changed--parameters","title":"Parameters","text":"<p>recipe_id : str     Recipe identifier. new_version : str     Newly discovered version.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.has_version_changed--returns","title":"Returns","text":"<p>bool     True if version changed or no cached version exists.</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.has_version_changed--examples","title":"Examples","text":"<p>if tracker.has_version_changed(\"napt-chrome\", \"130.0.0\"): ...     print(\"New version available!\")</p>"},{"location":"api/state/#notapkgtool.state.StateTracker.has_version_changed--notes","title":"Notes","text":"<p>Uses 'known_version' field which is informational only. Real version should be extracted from filesystem during build.</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def has_version_changed(self, recipe_id: str, new_version: str) -&gt; bool:\n    \"\"\"\n    Check if discovered version differs from cached known_version.\n\n    Parameters\n    ----------\n    recipe_id : str\n        Recipe identifier.\n    new_version : str\n        Newly discovered version.\n\n    Returns\n    -------\n    bool\n        True if version changed or no cached version exists.\n\n    Examples\n    --------\n    &gt;&gt;&gt; if tracker.has_version_changed(\"napt-chrome\", \"130.0.0\"):\n    ...     print(\"New version available!\")\n\n    Notes\n    -----\n    Uses 'known_version' field which is informational only.\n    Real version should be extracted from filesystem during build.\n    \"\"\"\n    cache = self.get_cache(recipe_id)\n    if not cache:\n        return True  # No cache, treat as changed\n\n    return cache.get(\"known_version\") != new_version\n</code></pre>"},{"location":"api/state/#notapkgtool.state.load_state","title":"<code>load_state(state_file)</code>","text":"<p>Load state from JSON file.</p>"},{"location":"api/state/#notapkgtool.state.load_state--parameters","title":"Parameters","text":"<p>state_file : Path     Path to JSON state file.</p>"},{"location":"api/state/#notapkgtool.state.load_state--returns","title":"Returns","text":"<p>dict     Loaded state dictionary.</p>"},{"location":"api/state/#notapkgtool.state.load_state--raises","title":"Raises","text":"<p>FileNotFoundError     If state file doesn't exist. json.JSONDecodeError     If file contains invalid JSON. OSError     If file cannot be read due to permissions.</p>"},{"location":"api/state/#notapkgtool.state.load_state--examples","title":"Examples","text":"<p>from pathlib import Path state = load_state(Path(\"state/versions.json\")) apps = state.get(\"apps\", {})</p> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def load_state(state_file: Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Load state from JSON file.\n\n    Parameters\n    ----------\n    state_file : Path\n        Path to JSON state file.\n\n    Returns\n    -------\n    dict\n        Loaded state dictionary.\n\n    Raises\n    ------\n    FileNotFoundError\n        If state file doesn't exist.\n    json.JSONDecodeError\n        If file contains invalid JSON.\n    OSError\n        If file cannot be read due to permissions.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; state = load_state(Path(\"state/versions.json\"))\n    &gt;&gt;&gt; apps = state.get(\"apps\", {})\n    \"\"\"\n    with open(state_file, encoding=\"utf-8\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"api/state/#notapkgtool.state.save_state","title":"<code>save_state(state, state_file)</code>","text":"<p>Save state to JSON file with pretty-printing.</p> <p>Creates parent directories if needed. Uses 2-space indentation and sorted keys for consistent diffs in version control.</p>"},{"location":"api/state/#notapkgtool.state.save_state--parameters","title":"Parameters","text":"<p>state : dict     State dictionary to save. state_file : Path     Path to JSON state file.</p>"},{"location":"api/state/#notapkgtool.state.save_state--raises","title":"Raises","text":"<p>OSError     If file cannot be written due to permissions.</p>"},{"location":"api/state/#notapkgtool.state.save_state--examples","title":"Examples","text":"<p>from pathlib import Path state = {\"metadata\": {}, \"apps\": {}} save_state(state, Path(\"state/versions.json\"))</p>"},{"location":"api/state/#notapkgtool.state.save_state--notes","title":"Notes","text":"<ul> <li>Uses 2-space indentation for readability</li> <li>Sorts keys alphabetically for consistent diffs</li> <li>Adds trailing newline for git compatibility</li> </ul> Source code in <code>notapkgtool/state/tracker.py</code> <pre><code>def save_state(state: dict[str, Any], state_file: Path) -&gt; None:\n    \"\"\"\n    Save state to JSON file with pretty-printing.\n\n    Creates parent directories if needed. Uses 2-space indentation\n    and sorted keys for consistent diffs in version control.\n\n    Parameters\n    ----------\n    state : dict\n        State dictionary to save.\n    state_file : Path\n        Path to JSON state file.\n\n    Raises\n    ------\n    OSError\n        If file cannot be written due to permissions.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; state = {\"metadata\": {}, \"apps\": {}}\n    &gt;&gt;&gt; save_state(state, Path(\"state/versions.json\"))\n\n    Notes\n    -----\n    - Uses 2-space indentation for readability\n    - Sorts keys alphabetically for consistent diffs\n    - Adds trailing newline for git compatibility\n    \"\"\"\n    state_file.parent.mkdir(parents=True, exist_ok=True)\n\n    with open(state_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(state, f, indent=2, sort_keys=True)\n        f.write(\"\\n\")  # Trailing newline for git\n</code></pre>"},{"location":"api/versioning/","title":"Versioning Module","text":"<p>The versioning module provides version comparison and extraction utilities.</p> <p>This module defines two key dataclasses for version information:</p> <ul> <li>DiscoveredVersion: Used by file-first strategies (http_static) when version is extracted from downloaded files.</li> <li>VersionInfo: Used by version-first strategies (url_regex, github_release, http_json) when version is discovered without downloading.</li> </ul>"},{"location":"api/versioning/#version-comparison","title":"Version Comparison","text":""},{"location":"api/versioning/#notapkgtool.versioning.keys","title":"<code>notapkgtool.versioning.keys</code>","text":"<p>Core version comparison utilities for NAPT.</p> <p>This module is format-agnostic: it does NOT download or read files. It only parses and compares version strings consistently across sources (MSI, EXE, generic strings).</p> <p>Public API: - DiscoveredVersion: container for version discovered from downloaded files (file-first). - VersionInfo: container for version discovered without downloading (version-first). - version_key_any(): build a comparable key for any version string. - compare_any():     tri-state compare (-1, 0, 1). - is_newer_any():    True if remote &gt; current.</p>"},{"location":"api/versioning/#notapkgtool.versioning.keys.DiscoveredVersion","title":"<code>DiscoveredVersion</code>  <code>dataclass</code>","text":"<p>Container for a discovered version string.</p> <p>version: raw version string (e.g., \"140.0.7339.128\"). source:  where it came from (e.g., \"regex_in_url\", \"msi_product_version_from_file\").</p> Source code in <code>notapkgtool/versioning/keys.py</code> <pre><code>@dataclass(frozen=True)\nclass DiscoveredVersion:\n    \"\"\"\n    Container for a discovered version string.\n\n    version: raw version string (e.g., \"140.0.7339.128\").\n    source:  where it came from (e.g., \"regex_in_url\", \"msi_product_version_from_file\").\n    \"\"\"\n\n    version: str\n    source: str\n</code></pre>"},{"location":"api/versioning/#notapkgtool.versioning.keys.VersionInfo","title":"<code>VersionInfo</code>  <code>dataclass</code>","text":"<p>Container for version information discovered without downloading.</p> <p>Used by version-first strategies (url_regex, github_release, http_json) that can determine version and download URL without fetching the installer.</p> <p>version: raw version string (e.g., \"140.0.7339.128\"). download_url: URL to download the installer. source: strategy name for logging (e.g., \"url_regex\", \"github_release\").</p> Source code in <code>notapkgtool/versioning/keys.py</code> <pre><code>@dataclass(frozen=True)\nclass VersionInfo:\n    \"\"\"\n    Container for version information discovered without downloading.\n\n    Used by version-first strategies (url_regex, github_release, http_json)\n    that can determine version and download URL without fetching the installer.\n\n    version: raw version string (e.g., \"140.0.7339.128\").\n    download_url: URL to download the installer.\n    source: strategy name for logging (e.g., \"url_regex\", \"github_release\").\n    \"\"\"\n\n    version: str\n    download_url: str\n    source: str\n</code></pre>"},{"location":"api/versioning/#notapkgtool.versioning.keys.version_key_any","title":"<code>version_key_any(s, *, source='string')</code>","text":"<p>Compute a comparable key for any version string.</p> <ul> <li>MSI/EXE: purely numeric (truncated to 3/4 parts).</li> <li>Generic string: semver-like robust key; if no numeric prefix, fallback to (\"text\", raw).</li> </ul> Source code in <code>notapkgtool/versioning/keys.py</code> <pre><code>def version_key_any(s: str, *, source: SourceHint = \"string\") -&gt; tuple:\n    \"\"\"\n    Compute a comparable key for any version string.\n\n    - MSI/EXE: purely numeric (truncated to 3/4 parts).\n    - Generic string: semver-like robust key; if no numeric prefix, fallback to (\"text\", raw).\n    \"\"\"\n    if source in (\"msi\", \"exe\"):\n        nums = _clip_for_source(_ints_from_text(s), source)\n        return (\"num\", nums)\n\n    key = _semver_like_key_robust(s)\n    release = key[0]\n    if release != (0,):\n        # IMPORTANT: We do NOT include the raw string as a tiebreaker.\n        # This makes \"v1.2.3\" == \"1.2.3\" when the parsed keys are equal.\n        return (\"semverish\", key)\n\n    return (\"text\", s)\n</code></pre>"},{"location":"api/versioning/#notapkgtool.versioning.keys.compare_any","title":"<code>compare_any(a, b, *, source='string', verbose=False)</code>","text":"<p>Compare two versions with a source hint. Returns -1 if a &lt; b, 0 if equal, 1 if a &gt; b.</p> Source code in <code>notapkgtool/versioning/keys.py</code> <pre><code>def compare_any(\n    a: str,\n    b: str,\n    *,\n    source: SourceHint = \"string\",\n    verbose: bool = False,\n) -&gt; int:\n    \"\"\"\n    Compare two versions with a source hint.\n    Returns -1 if a &lt; b, 0 if equal, 1 if a &gt; b.\n    \"\"\"\n    if source in (\"msi\", \"exe\"):\n        try:\n            aa = _clip_for_source(_ints_from_text(a), source)\n            bb = _clip_for_source(_ints_from_text(b), source)\n            aa, bb = _pad_equal(aa, bb)\n            result = (aa &gt; bb) - (aa &lt; bb)\n        except ValueError:\n            # If vendor sneaks letters into numeric fields, fallback to generic parsing.\n            ka = version_key_any(a, source=\"string\")\n            kb = version_key_any(b, source=\"string\")\n            result = (ka &gt; kb) - (ka &lt; kb)\n    else:\n        ka = version_key_any(a, source=\"string\")\n        kb = version_key_any(b, source=\"string\")\n        result = (ka &gt; kb) - (ka &lt; kb)\n\n    if verbose:\n        if result &lt; 0:\n            print(f\"[compare_any] {a!r} is older than {b!r} (source={source})\")\n        elif result &gt; 0:\n            print(f\"[compare_any] {a!r} is newer than {b!r} (source={source})\")\n        else:\n            print(f\"[compare_any] {a!r} is the same as {b!r} (source={source})\")\n    return result\n</code></pre>"},{"location":"api/versioning/#notapkgtool.versioning.keys.is_newer_any","title":"<code>is_newer_any(remote, current, *, source='string', verbose=False)</code>","text":"<p>Decide if 'remote' should be considered newer than 'current'. Returns True iff remote &gt; current under the given source semantics.</p> Source code in <code>notapkgtool/versioning/keys.py</code> <pre><code>def is_newer_any(\n    remote: str,\n    current: str | None,\n    *,\n    source: SourceHint = \"string\",\n    verbose: bool = False,\n) -&gt; bool:\n    \"\"\"\n    Decide if 'remote' should be considered newer than 'current'.\n    Returns True iff remote &gt; current under the given source semantics.\n    \"\"\"\n    if current is None:\n        if verbose:\n            print(\n                f\"[is_newer_any] No current version. Treat {remote!r} as newer (source={source})\"\n            )\n        return True\n\n    cmpv = compare_any(remote, current, source=source, verbose=verbose)\n    if verbose:\n        if cmpv &gt; 0:\n            print(\n                f\"[is_newer_any] Remote {remote!r} is newer than current {current!r} (source={source})\"\n            )\n        elif cmpv == 0:\n            print(\n                f\"[is_newer_any] Remote {remote!r} is the same as current {current!r} (source={source})\"\n            )\n        else:\n            print(\n                f\"[is_newer_any] Remote {remote!r} is older than current {current!r} (source={source})\"\n            )\n    return cmpv &gt; 0\n</code></pre>"},{"location":"api/versioning/#msi-version-extraction","title":"MSI Version Extraction","text":""},{"location":"api/versioning/#notapkgtool.versioning.msi","title":"<code>notapkgtool.versioning.msi</code>","text":"<p>MSI ProductVersion extraction for NAPT.</p> <p>This module extracts the ProductVersion property from Windows Installer (MSI) database files. It tries multiple backends in order of preference to maximize cross-platform compatibility.</p>"},{"location":"api/versioning/#notapkgtool.versioning.msi--backend-priority","title":"Backend Priority","text":"<p>On Windows:   1. msilib (Python standard library, Python 3.11+)   2. _msi (CPython extension module, Windows-specific)   3. PowerShell COM (Windows Installer COM API, always available)</p> <p>On Linux/macOS:   1. msiinfo (from msitools package, must be installed separately)</p> <p>The PowerShell fallback makes this truly universal on Windows systems, even when Python MSI libraries aren't available.</p>"},{"location":"api/versioning/#notapkgtool.versioning.msi--functions","title":"Functions","text":"<p>version_from_msi_product_version : function     Extract ProductVersion from an MSI file using available backends.</p>"},{"location":"api/versioning/#notapkgtool.versioning.msi--installation-requirements","title":"Installation Requirements","text":"<p>Windows:   - No additional packages required (PowerShell fallback always works)   - Optional: Ensure msilib is available for better performance</p> <p>Linux/macOS:   - Install msitools package:     - Debian/Ubuntu: sudo apt-get install msitools     - RHEL/Fedora: sudo dnf install msitools     - macOS: brew install msitools</p>"},{"location":"api/versioning/#notapkgtool.versioning.msi--examples","title":"Examples","text":"<p>Extract version from MSI:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from notapkgtool.versioning.msi import version_from_msi_product_version\n&gt;&gt;&gt; discovered = version_from_msi_product_version(\"chrome.msi\")\n&gt;&gt;&gt; print(f\"{discovered.version} from {discovered.source}\")\n141.0.7390.123 from msi_product_version_from_file\n</code></pre> <p>Error handling:</p> <pre><code>&gt;&gt;&gt; try:\n...     discovered = version_from_msi_product_version(\"missing.msi\")\n... except FileNotFoundError:\n...     print(\"MSI file not found\")\n... except RuntimeError as e:\n...     print(f\"Extraction failed: {e}\")\n</code></pre>"},{"location":"api/versioning/#notapkgtool.versioning.msi--notes","title":"Notes","text":"<ul> <li>This is pure file introspection; no network calls are made</li> <li>All backends query the MSI Property table for ProductVersion</li> <li>The PowerShell approach uses COM (WindowsInstaller.Installer)</li> <li>Errors are chained for debugging (check 'from err' clause)</li> </ul>"},{"location":"api/versioning/#notapkgtool.versioning.msi.version_from_msi_product_version","title":"<code>version_from_msi_product_version(file_path, verbose=False, debug=False)</code>","text":"<p>Extract ProductVersion from an MSI file.</p> <p>Backends (tried in order): - Windows: 'msilib' from Python standard library (Python 3.11+). - Windows: CPython '_msi' extension (alternative). - Elsewhere: 'msiinfo' from 'msitools' if available in PATH. - If none available, raises NotImplementedError.</p>"},{"location":"api/versioning/#notapkgtool.versioning.msi.version_from_msi_product_version--raises","title":"Raises","text":"<p>FileNotFoundError | RuntimeError | NotImplementedError</p> Source code in <code>notapkgtool/versioning/msi.py</code> <pre><code>def version_from_msi_product_version(\n    file_path: str | Path, verbose: bool = False, debug: bool = False\n) -&gt; DiscoveredVersion:\n    \"\"\"\n    Extract ProductVersion from an MSI file.\n\n    Backends (tried in order):\n    - Windows: 'msilib' from Python standard library (Python 3.11+).\n    - Windows: CPython '_msi' extension (alternative).\n    - Elsewhere: 'msiinfo' from 'msitools' if available in PATH.\n    - If none available, raises NotImplementedError.\n\n    Raises\n    ------\n    FileNotFoundError | RuntimeError | NotImplementedError\n    \"\"\"\n    from notapkgtool.cli import print_debug, print_verbose\n\n    p = Path(file_path)\n    if not p.exists():\n        raise FileNotFoundError(f\"MSI not found: {p}\")\n\n    print_verbose(\"VERSION\", \"Strategy: msi_product_version_from_file\")\n    print_verbose(\"VERSION\", f\"Extracting version from: {p.name}\")\n\n    # Try msilib first (standard library on Windows)\n    if sys.platform.startswith(\"win\") and msilib is not None:\n        print_debug(\"VERSION\", \"Trying backend: msilib...\")\n        try:\n            db = msilib.OpenDatabase(str(p), msilib.MSIDBOPEN_READONLY)\n            view = db.OpenView(\n                \"SELECT `Value` FROM `Property` WHERE `Property`='ProductVersion'\"\n            )\n            view.Execute(None)\n            rec = view.Fetch()\n            if rec is None:\n                db.Close()\n                raise RuntimeError(\"ProductVersion not found in MSI Property table.\")\n            version = rec.GetString(1)\n            db.Close()\n            if not version:\n                raise RuntimeError(\"Empty ProductVersion in MSI Property table.\")\n            print_verbose(\"VERSION\", f\"Success! Extracted: {version} (via msilib)\")\n            return DiscoveredVersion(\n                version=version, source=\"msi_product_version_from_file\"\n            )\n        except Exception as err:\n            print_debug(\"VERSION\", \"msilib failed, trying next backend...\")\n            raise RuntimeError(\n                f\"failed to read MSI ProductVersion via msilib: {err}\"\n            ) from err\n\n    # Try _msi module (alternative Windows approach)\n    if sys.platform.startswith(\"win\"):\n        print_debug(\"VERSION\", \"Trying backend: _msi...\")\n        try:\n            import _msi  # type: ignore\n        except ImportError:\n            # _msi not available, fall through to msiinfo\n            print_debug(\"VERSION\", \"_msi not available, trying next backend...\")\n            pass\n        else:\n            try:\n                db = _msi.OpenDatabase(str(p), 0)  # 0: read-only\n                view = db.OpenView(\n                    \"SELECT `Value` FROM `Property` WHERE `Property`='ProductVersion'\"\n                )\n                view.Execute(None)\n                rec = view.Fetch()\n                if rec is None:\n                    raise RuntimeError(\n                        \"ProductVersion not found in MSI Property table.\"\n                    )\n                version = rec.GetString(1)\n                if not version:\n                    raise RuntimeError(\"Empty ProductVersion in MSI Property table.\")\n                view.Close()\n                db.Close()\n                print_verbose(\"VERSION\", f\"Success! Extracted: {version} (via _msi)\")\n                return DiscoveredVersion(\n                    version=version, source=\"msi_product_version_from_file\"\n                )\n            except Exception as err:\n                print_debug(\"VERSION\", \"_msi failed, trying next backend...\")\n                raise RuntimeError(\n                    f\"failed to read MSI ProductVersion via _msi: {err}\"\n                ) from err\n\n    # Try PowerShell with Windows Installer COM on Windows\n    if sys.platform.startswith(\"win\"):\n        print_debug(\"VERSION\", \"Trying backend: PowerShell COM...\")\n        try:\n            ps_script = f\"\"\"\n$installer = New-Object -ComObject WindowsInstaller.Installer\n$db = $installer.OpenDatabase('{p}', 0)\n$view = $db.OpenView(\"SELECT Value FROM Property WHERE Property='ProductVersion'\")\n$view.Execute()\n$record = $view.Fetch()\nif ($record) {{\n    $record.StringData(1)\n}} else {{\n    Write-Error \"ProductVersion not found\"\n    exit 1\n}}\n\"\"\"\n            result = subprocess.run(\n                [\"powershell\", \"-NoProfile\", \"-NonInteractive\", \"-Command\", ps_script],\n                check=True,\n                capture_output=True,\n                text=True,\n                timeout=10,\n            )\n            version = result.stdout.strip()\n            if version:\n                print_verbose(\n                    \"VERSION\", f\"Success! Extracted: {version} (via PowerShell COM)\"\n                )\n                return DiscoveredVersion(\n                    version=version, source=\"msi_product_version_from_file\"\n                )\n        except subprocess.CalledProcessError as err:\n            print_debug(\"VERSION\", \"PowerShell COM failed, trying next backend...\")\n            raise RuntimeError(f\"PowerShell MSI query failed: {err}\") from err\n        except subprocess.TimeoutExpired:\n            print_debug(\"VERSION\", \"PowerShell COM timed out, trying next backend...\")\n            raise RuntimeError(\"PowerShell MSI query timed out\") from None\n\n    # Try msiinfo on Linux/macOS\n    msiinfo = shutil.which(\"msiinfo\")\n    if msiinfo:\n        print_debug(\"VERSION\", \"Trying backend: msiinfo (msitools)...\")\n        try:\n            # msiinfo export &lt;package&gt; Property -&gt; stdout (tab-separated)\n            result = subprocess.run(\n                [msiinfo, \"export\", str(p), \"Property\"],\n                check=True,\n                capture_output=True,\n                text=True,\n            )\n            version_str: str | None = None\n            for line in result.stdout.splitlines():\n                parts = line.strip().split(\"\\t\", 1)  # \"Property&lt;TAB&gt;Value\"\n                if len(parts) == 2 and parts[0] == \"ProductVersion\":\n                    version_str = parts[1]\n                    break\n            if not version_str:\n                raise RuntimeError(\"ProductVersion not found in MSI Property output.\")\n            print_verbose(\"VERSION\", f\"Success! Extracted: {version_str} (via msiinfo)\")\n            return DiscoveredVersion(\n                version=version_str, source=\"msi_product_version_from_file\"\n            )\n        except subprocess.CalledProcessError as err:\n            print_debug(\"VERSION\", \"msiinfo failed\")\n            raise RuntimeError(f\"msiinfo failed: {err}\") from err\n\n    print_debug(\"VERSION\", \"No MSI extraction backend available on this system\")\n    raise NotImplementedError(\n        \"MSI version extraction is not available on this host. \"\n        \"On Windows, ensure PowerShell is available. \"\n        \"On Linux/macOS, install 'msitools'.\"\n    )\n</code></pre>"},{"location":"api/versioning/#url-regex-extraction","title":"URL Regex Extraction","text":""},{"location":"api/versioning/#notapkgtool.versioning.url_regex","title":"<code>notapkgtool.versioning.url_regex</code>","text":"<p>URL regex version extraction for NAPT.</p> <p>This module extracts version information from URLs using regular expressions. It's useful when vendors encode version numbers in their download URLs, allowing version discovery without downloading the entire file first.</p>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex--use-cases","title":"Use Cases","text":"<ul> <li>Vendors with version-encoded URLs (e.g., app-v1.2.3-installer.msi)</li> <li>APIs that return version-specific download links</li> <li>URLs with semantic version patterns in the path</li> </ul>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex--functions","title":"Functions","text":"<p>version_from_regex_in_url : function     Extract version string from a URL using a regex pattern.</p>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex--pattern-syntax","title":"Pattern Syntax","text":"<p>Patterns support full Python regex syntax. Two extraction modes:</p> <ol> <li> <p>Named capture group (recommended):    pattern = r\"app-v(?P[0-9.]+)-installer\"    Extracts only the 'version' group from the match. <li> <p>Full match (fallback):    pattern = r\"[0-9]+.[0-9]+.[0-9]+\"    Uses the entire regex match as the version.</p> </li>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex--examples","title":"Examples","text":"<p>Extract version from URL with named group:</p> <pre><code>&gt;&gt;&gt; from notapkgtool.versioning.url_regex import version_from_regex_in_url\n&gt;&gt;&gt; url = \"https://vendor.com/downloads/myapp-v1.2.3-setup.msi\"\n&gt;&gt;&gt; pattern = r\"myapp-v(?P&lt;version&gt;[0-9.]+)-setup\"\n&gt;&gt;&gt; discovered = version_from_regex_in_url(url, pattern)\n&gt;&gt;&gt; print(f\"{discovered.version} from {discovered.source}\")\n1.2.3 from regex_in_url\n</code></pre> <p>Extract version with full match:</p> <pre><code>&gt;&gt;&gt; url = \"https://vendor.com/app/2024.10.28/installer.exe\"\n&gt;&gt;&gt; pattern = \"[0-9]{4}\\\\.[0-9]{2}\\\\.[0-9]{2}\"\n&gt;&gt;&gt; discovered = version_from_regex_in_url(url, pattern)\n&gt;&gt;&gt; discovered.version\n'2024.10.28'\n</code></pre> <p>Error handling:</p> <pre><code>&gt;&gt;&gt; try:\n...     url = \"https://vendor.com/app.msi\"\n...     pattern = r\"v(?P&lt;version&gt;[0-9.]+)\"\n...     discovered = version_from_regex_in_url(url, pattern)\n... except ValueError as e:\n...     print(f\"Pattern did not match: {e}\")\n</code></pre>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex--notes","title":"Notes","text":"<ul> <li>This is pure string extraction; no network calls are made</li> <li>The extracted version is not validated for format</li> <li>Empty version strings will raise ValueError</li> <li>Regex compilation errors propagate as-is</li> </ul>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex.version_from_regex_in_url","title":"<code>version_from_regex_in_url(url, pattern, verbose=False, debug=False)</code>","text":"<p>Extract a version from a URL using a regular expression.</p> <p>The function searches for the pattern in the URL and extracts the version based on capture groups. If a named group (?P) exists, that group is used; otherwise, the entire match is used."},{"location":"api/versioning/#notapkgtool.versioning.url_regex.version_from_regex_in_url--parameters","title":"Parameters","text":"<p>url : str     The URL to extract the version from. Can be a full URL or just a path. pattern : str     Regular expression pattern to match. Use (?P...) for a named     capture group to extract only the version portion. verbose : bool, optional     If True, print verbose logging messages. Default is False. debug : bool, optional     If True, print debug logging messages. Default is False."},{"location":"api/versioning/#notapkgtool.versioning.url_regex.version_from_regex_in_url--returns","title":"Returns","text":"<p>DiscoveredVersion     Container with the extracted version string and source='regex_in_url'.</p>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex.version_from_regex_in_url--raises","title":"Raises","text":"<p>ValueError     If the pattern does not match the URL, or if the extracted version     is empty. re.error     If the regex pattern is invalid (propagates from re.search).</p>"},{"location":"api/versioning/#notapkgtool.versioning.url_regex.version_from_regex_in_url--examples","title":"Examples","text":"<p>Extract with named capture group:</p> <pre><code>&gt;&gt;&gt; url = \"https://vendor.com/app-v2.1.0-installer.msi\"\n&gt;&gt;&gt; pattern = r\"app-v(?P&lt;version&gt;[0-9.]+)-installer\"\n&gt;&gt;&gt; discovered = version_from_regex_in_url(url, pattern)\n&gt;&gt;&gt; discovered.version\n'2.1.0'\n</code></pre> <p>Extract with full match:</p> <pre><code>&gt;&gt;&gt; url = \"https://vendor.com/downloads/1.2.3/setup.exe\"\n&gt;&gt;&gt; pattern = r\"[0-9]+\\.[0-9]+\\.[0-9]+\"\n&gt;&gt;&gt; discovered = version_from_regex_in_url(url, pattern)\n&gt;&gt;&gt; discovered.version\n'1.2.3'\n</code></pre> Source code in <code>notapkgtool/versioning/url_regex.py</code> <pre><code>def version_from_regex_in_url(\n    url: str, pattern: str, verbose: bool = False, debug: bool = False\n) -&gt; DiscoveredVersion:\n    \"\"\"\n    Extract a version from a URL using a regular expression.\n\n    The function searches for the pattern in the URL and extracts the version\n    based on capture groups. If a named group (?P&lt;version&gt;) exists, that group\n    is used; otherwise, the entire match is used.\n\n    Parameters\n    ----------\n    url : str\n        The URL to extract the version from. Can be a full URL or just a path.\n    pattern : str\n        Regular expression pattern to match. Use (?P&lt;version&gt;...) for a named\n        capture group to extract only the version portion.\n    verbose : bool, optional\n        If True, print verbose logging messages. Default is False.\n    debug : bool, optional\n        If True, print debug logging messages. Default is False.\n\n    Returns\n    -------\n    DiscoveredVersion\n        Container with the extracted version string and source='regex_in_url'.\n\n    Raises\n    ------\n    ValueError\n        If the pattern does not match the URL, or if the extracted version\n        is empty.\n    re.error\n        If the regex pattern is invalid (propagates from re.search).\n\n    Examples\n    --------\n    Extract with named capture group:\n\n        &gt;&gt;&gt; url = \"https://vendor.com/app-v2.1.0-installer.msi\"\n        &gt;&gt;&gt; pattern = r\"app-v(?P&lt;version&gt;[0-9.]+)-installer\"\n        &gt;&gt;&gt; discovered = version_from_regex_in_url(url, pattern)\n        &gt;&gt;&gt; discovered.version\n        '2.1.0'\n\n    Extract with full match:\n\n        &gt;&gt;&gt; url = \"https://vendor.com/downloads/1.2.3/setup.exe\"\n        &gt;&gt;&gt; pattern = r\"[0-9]+\\\\.[0-9]+\\\\.[0-9]+\"\n        &gt;&gt;&gt; discovered = version_from_regex_in_url(url, pattern)\n        &gt;&gt;&gt; discovered.version\n        '1.2.3'\n    \"\"\"\n    from notapkgtool.cli import print_debug, print_verbose\n\n    print_verbose(\"VERSION\", \"Strategy: regex_in_url\")\n    print_verbose(\"VERSION\", f\"Pattern: {pattern}\")\n    print_debug(\"VERSION\", f\"URL: {url}\")\n\n    try:\n        m = re.search(pattern, url)\n    except re.error as err:\n        raise ValueError(f\"Invalid regex pattern: {pattern!r}\") from err\n\n    if not m:\n        raise ValueError(\n            f\"Pattern did not match URL. Pattern: {pattern!r}, URL: {url!r}\"\n        )\n\n    # Use named group 'version' if present, otherwise use full match\n    ver = m.group(\"version\") if \"version\" in (m.groupdict() or {}) else m.group(0)\n\n    if not ver:\n        raise ValueError(\n            f\"Extracted version is empty. Pattern: {pattern!r}, URL: {url!r}\"\n        )\n\n    print_verbose(\"VERSION\", f\"Success! Extracted: {ver} (via regex)\")\n    print_debug(\"VERSION\", f\"Match details: {m.groups()}\")\n\n    return DiscoveredVersion(version=ver, source=\"regex_in_url\")\n</code></pre>"}]}